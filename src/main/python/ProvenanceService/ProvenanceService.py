#   Copyright (C) 2013-2014 Computer Sciences Corporation
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import ezbakeBaseService.EzBakeBaseService
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(ezbakeBaseService.EzBakeBaseService.Iface):
  def addAgeOffRule(self, securityToken, name, retentionDurationSeconds, maximumExecutionPeriod):
    """
    Parameters:
     - securityToken
     - name
     - retentionDurationSeconds
     - maximumExecutionPeriod
    """
    pass

  def getAgeOffRuleById(self, securityToken, ruleId):
    """
    Parameters:
     - securityToken
     - ruleId
    """
    pass

  def getAgeOffRule(self, securityToken, name):
    """
    Parameters:
     - securityToken
     - name
    """
    pass

  def updateAgeOffRule(self, securityToken, name, retentionDurationSeconds):
    """
    Parameters:
     - securityToken
     - name
     - retentionDurationSeconds
    """
    pass

  def getAllAgeOffRules(self, securityToken, limit, page):
    """
    Parameters:
     - securityToken
     - limit
     - page
    """
    pass

  def countAgeOffRules(self, securityToken):
    """
    Parameters:
     - securityToken
    """
    pass

  def addDocument(self, token, uri, parents, ageOffRules):
    """
    Parameters:
     - token
     - uri
     - parents
     - ageOffRules
    """
    pass

  def addDocuments(self, securityToken, documents, ageOffRules):
    """
    Parameters:
     - securityToken
     - documents
     - ageOffRules
    """
    pass

  def getAddDocumentsMaxSize(self, securityToken):
    """
    Parameters:
     - securityToken
    """
    pass

  def startAgeOffEvent(self, securityToken, ruleId, effectiveTime):
    """
    Parameters:
     - securityToken
     - ruleId
     - effectiveTime
    """
    pass

  def markDocumentAsAged(self, securityToken, agedDocumentIds):
    """
    Parameters:
     - securityToken
     - agedDocumentIds
    """
    pass

  def getDocumentInfo(self, securityToken, id, uri):
    """
    Parameters:
     - securityToken
     - id
     - uri
    """
    pass

  def getDocumentAncestors(self, securityToken, uris):
    """
    Parameters:
     - securityToken
     - uris
    """
    pass

  def getDocumentDescendants(self, securityToken, uris):
    """
    Parameters:
     - securityToken
     - uris
    """
    pass

  def markDocumentForPurge(self, securityToken, uris, name, description):
    """
    Parameters:
     - securityToken
     - uris
     - name
     - description
    """
    pass

  def getDocumentUriFromId(self, securityToken, positionsList):
    """
    Parameters:
     - securityToken
     - positionsList
    """
    pass

  def getDocumentConvertedUrisFromIds(self, securityToken, ids):
    """
    Parameters:
     - securityToken
     - ids
    """
    pass

  def getDocumentConvertedUrisFromUris(self, securityToken, uris):
    """
    Parameters:
     - securityToken
     - uris
    """
    pass

  def getPurgeInfo(self, securityToken, purgeId):
    """
    Parameters:
     - securityToken
     - purgeId
    """
    pass

  def getAllPurgeIds(self, securityToken):
    """
    Parameters:
     - securityToken
    """
    pass

  def updatePurge(self, securityToken, purgeId, completelyPurged, note, resolved):
    """
    Parameters:
     - securityToken
     - purgeId
     - completelyPurged
     - note
     - resolved
    """
    pass

  def removeDocumentAgeOffRuleInheritance(self, securityToken, documentId, documentUri, parentId, parentUri):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - parentId
     - parentUri
    """
    pass

  def removeDocumentExplicitAgeOffRule(self, securityToken, documentId, documentUri, ageOffRuleId):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - ageOffRuleId
    """
    pass

  def addDocumentExplicitAgeOffRule(self, securityToken, documentId, documentUri, ageOffMapping):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - ageOffMapping
    """
    pass

  def addDocumentInheritanceInfo(self, securityToken, documentId, documentUri, inheritanceInfo):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - inheritanceInfo
    """
    pass

  def recordObjectAccess(self, securityToken, documentUri, accessType):
    """
    Parameters:
     - securityToken
     - documentUri
     - accessType
    """
    pass

  def fetchUsersDocuments(self, securityToken, userPrincipal, startDateTime, stopDateTime, numToFetch, continuationPoint):
    """
    Parameters:
     - securityToken
     - userPrincipal
     - startDateTime
     - stopDateTime
     - numToFetch
     - continuationPoint
    """
    pass

  def fetchDocumentUsers(self, securityToken, documentUri, startDateTime, stopDateTime, numToFetch, continuationPoint):
    """
    Parameters:
     - securityToken
     - documentUri
     - startDateTime
     - stopDateTime
     - numToFetch
     - continuationPoint
    """
    pass


class Client(ezbakeBaseService.EzBakeBaseService.Client, Iface):
  def __init__(self, iprot, oprot=None):
    ezbakeBaseService.EzBakeBaseService.Client.__init__(self, iprot, oprot)

  def addAgeOffRule(self, securityToken, name, retentionDurationSeconds, maximumExecutionPeriod):
    """
    Parameters:
     - securityToken
     - name
     - retentionDurationSeconds
     - maximumExecutionPeriod
    """
    self.send_addAgeOffRule(securityToken, name, retentionDurationSeconds, maximumExecutionPeriod)
    return self.recv_addAgeOffRule()

  def send_addAgeOffRule(self, securityToken, name, retentionDurationSeconds, maximumExecutionPeriod):
    self._oprot.writeMessageBegin('addAgeOffRule', TMessageType.CALL, self._seqid)
    args = addAgeOffRule_args()
    args.securityToken = securityToken
    args.name = name
    args.retentionDurationSeconds = retentionDurationSeconds
    args.maximumExecutionPeriod = maximumExecutionPeriod
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addAgeOffRule(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addAgeOffRule_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.nameExists is not None:
      raise result.nameExists
    if result.illegalAgeOffDurationSeconds is not None:
      raise result.illegalAgeOffDurationSeconds
    if result.illegalAgeOffName is not None:
      raise result.illegalAgeOffName
    if result.illegalMaxPeriod is not None:
      raise result.illegalMaxPeriod
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addAgeOffRule failed: unknown result");

  def getAgeOffRuleById(self, securityToken, ruleId):
    """
    Parameters:
     - securityToken
     - ruleId
    """
    self.send_getAgeOffRuleById(securityToken, ruleId)
    return self.recv_getAgeOffRuleById()

  def send_getAgeOffRuleById(self, securityToken, ruleId):
    self._oprot.writeMessageBegin('getAgeOffRuleById', TMessageType.CALL, self._seqid)
    args = getAgeOffRuleById_args()
    args.securityToken = securityToken
    args.ruleId = ruleId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAgeOffRuleById(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAgeOffRuleById_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAgeOffRuleById failed: unknown result");

  def getAgeOffRule(self, securityToken, name):
    """
    Parameters:
     - securityToken
     - name
    """
    self.send_getAgeOffRule(securityToken, name)
    return self.recv_getAgeOffRule()

  def send_getAgeOffRule(self, securityToken, name):
    self._oprot.writeMessageBegin('getAgeOffRule', TMessageType.CALL, self._seqid)
    args = getAgeOffRule_args()
    args.securityToken = securityToken
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAgeOffRule(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAgeOffRule_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAgeOffRule failed: unknown result");

  def updateAgeOffRule(self, securityToken, name, retentionDurationSeconds):
    """
    Parameters:
     - securityToken
     - name
     - retentionDurationSeconds
    """
    self.send_updateAgeOffRule(securityToken, name, retentionDurationSeconds)
    self.recv_updateAgeOffRule()

  def send_updateAgeOffRule(self, securityToken, name, retentionDurationSeconds):
    self._oprot.writeMessageBegin('updateAgeOffRule', TMessageType.CALL, self._seqid)
    args = updateAgeOffRule_args()
    args.securityToken = securityToken
    args.name = name
    args.retentionDurationSeconds = retentionDurationSeconds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateAgeOffRule(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateAgeOffRule_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    if result.illegalAgeOffDurationSeconds is not None:
      raise result.illegalAgeOffDurationSeconds
    if result.illegalAgeOffName is not None:
      raise result.illegalAgeOffName
    return

  def getAllAgeOffRules(self, securityToken, limit, page):
    """
    Parameters:
     - securityToken
     - limit
     - page
    """
    self.send_getAllAgeOffRules(securityToken, limit, page)
    return self.recv_getAllAgeOffRules()

  def send_getAllAgeOffRules(self, securityToken, limit, page):
    self._oprot.writeMessageBegin('getAllAgeOffRules', TMessageType.CALL, self._seqid)
    args = getAllAgeOffRules_args()
    args.securityToken = securityToken
    args.limit = limit
    args.page = page
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllAgeOffRules(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllAgeOffRules_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllAgeOffRules failed: unknown result");

  def countAgeOffRules(self, securityToken):
    """
    Parameters:
     - securityToken
    """
    self.send_countAgeOffRules(securityToken)
    return self.recv_countAgeOffRules()

  def send_countAgeOffRules(self, securityToken):
    self._oprot.writeMessageBegin('countAgeOffRules', TMessageType.CALL, self._seqid)
    args = countAgeOffRules_args()
    args.securityToken = securityToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_countAgeOffRules(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = countAgeOffRules_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "countAgeOffRules failed: unknown result");

  def addDocument(self, token, uri, parents, ageOffRules):
    """
    Parameters:
     - token
     - uri
     - parents
     - ageOffRules
    """
    self.send_addDocument(token, uri, parents, ageOffRules)
    return self.recv_addDocument()

  def send_addDocument(self, token, uri, parents, ageOffRules):
    self._oprot.writeMessageBegin('addDocument', TMessageType.CALL, self._seqid)
    args = addDocument_args()
    args.token = token
    args.uri = uri
    args.parents = parents
    args.ageOffRules = ageOffRules
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addDocument(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addDocument_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.documentExists is not None:
      raise result.documentExists
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    if result.parentNotFound is not None:
      raise result.parentNotFound
    if result.circularInheritanceNotAllowed is not None:
      raise result.circularInheritanceNotAllowed
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addDocument failed: unknown result");

  def addDocuments(self, securityToken, documents, ageOffRules):
    """
    Parameters:
     - securityToken
     - documents
     - ageOffRules
    """
    self.send_addDocuments(securityToken, documents, ageOffRules)
    return self.recv_addDocuments()

  def send_addDocuments(self, securityToken, documents, ageOffRules):
    self._oprot.writeMessageBegin('addDocuments', TMessageType.CALL, self._seqid)
    args = addDocuments_args()
    args.securityToken = securityToken
    args.documents = documents
    args.ageOffRules = ageOffRules
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addDocuments(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addDocuments_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    if result.exceedsMaxSize is not None:
      raise result.exceedsMaxSize
    raise TApplicationException(TApplicationException.MISSING_RESULT, "addDocuments failed: unknown result");

  def getAddDocumentsMaxSize(self, securityToken):
    """
    Parameters:
     - securityToken
    """
    self.send_getAddDocumentsMaxSize(securityToken)
    return self.recv_getAddDocumentsMaxSize()

  def send_getAddDocumentsMaxSize(self, securityToken):
    self._oprot.writeMessageBegin('getAddDocumentsMaxSize', TMessageType.CALL, self._seqid)
    args = getAddDocumentsMaxSize_args()
    args.securityToken = securityToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAddDocumentsMaxSize(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAddDocumentsMaxSize_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAddDocumentsMaxSize failed: unknown result");

  def startAgeOffEvent(self, securityToken, ruleId, effectiveTime):
    """
    Parameters:
     - securityToken
     - ruleId
     - effectiveTime
    """
    self.send_startAgeOffEvent(securityToken, ruleId, effectiveTime)
    return self.recv_startAgeOffEvent()

  def send_startAgeOffEvent(self, securityToken, ruleId, effectiveTime):
    self._oprot.writeMessageBegin('startAgeOffEvent', TMessageType.CALL, self._seqid)
    args = startAgeOffEvent_args()
    args.securityToken = securityToken
    args.ruleId = ruleId
    args.effectiveTime = effectiveTime
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startAgeOffEvent(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startAgeOffEvent_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startAgeOffEvent failed: unknown result");

  def markDocumentAsAged(self, securityToken, agedDocumentIds):
    """
    Parameters:
     - securityToken
     - agedDocumentIds
    """
    self.send_markDocumentAsAged(securityToken, agedDocumentIds)
    self.recv_markDocumentAsAged()

  def send_markDocumentAsAged(self, securityToken, agedDocumentIds):
    self._oprot.writeMessageBegin('markDocumentAsAged', TMessageType.CALL, self._seqid)
    args = markDocumentAsAged_args()
    args.securityToken = securityToken
    args.agedDocumentIds = agedDocumentIds
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markDocumentAsAged(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = markDocumentAsAged_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    if result.documentNotFound is not None:
      raise result.documentNotFound
    return

  def getDocumentInfo(self, securityToken, id, uri):
    """
    Parameters:
     - securityToken
     - id
     - uri
    """
    self.send_getDocumentInfo(securityToken, id, uri)
    return self.recv_getDocumentInfo()

  def send_getDocumentInfo(self, securityToken, id, uri):
    self._oprot.writeMessageBegin('getDocumentInfo', TMessageType.CALL, self._seqid)
    args = getDocumentInfo_args()
    args.securityToken = securityToken
    args.id = id
    args.uri = uri
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDocumentInfo(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDocumentInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.docNotFound is not None:
      raise result.docNotFound
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDocumentInfo failed: unknown result");

  def getDocumentAncestors(self, securityToken, uris):
    """
    Parameters:
     - securityToken
     - uris
    """
    self.send_getDocumentAncestors(securityToken, uris)
    return self.recv_getDocumentAncestors()

  def send_getDocumentAncestors(self, securityToken, uris):
    self._oprot.writeMessageBegin('getDocumentAncestors', TMessageType.CALL, self._seqid)
    args = getDocumentAncestors_args()
    args.securityToken = securityToken
    args.uris = uris
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDocumentAncestors(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDocumentAncestors_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDocumentAncestors failed: unknown result");

  def getDocumentDescendants(self, securityToken, uris):
    """
    Parameters:
     - securityToken
     - uris
    """
    self.send_getDocumentDescendants(securityToken, uris)
    return self.recv_getDocumentDescendants()

  def send_getDocumentDescendants(self, securityToken, uris):
    self._oprot.writeMessageBegin('getDocumentDescendants', TMessageType.CALL, self._seqid)
    args = getDocumentDescendants_args()
    args.securityToken = securityToken
    args.uris = uris
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDocumentDescendants(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDocumentDescendants_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDocumentDescendants failed: unknown result");

  def markDocumentForPurge(self, securityToken, uris, name, description):
    """
    Parameters:
     - securityToken
     - uris
     - name
     - description
    """
    self.send_markDocumentForPurge(securityToken, uris, name, description)
    return self.recv_markDocumentForPurge()

  def send_markDocumentForPurge(self, securityToken, uris, name, description):
    self._oprot.writeMessageBegin('markDocumentForPurge', TMessageType.CALL, self._seqid)
    args = markDocumentForPurge_args()
    args.securityToken = securityToken
    args.uris = uris
    args.name = name
    args.description = description
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_markDocumentForPurge(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = markDocumentForPurge_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "markDocumentForPurge failed: unknown result");

  def getDocumentUriFromId(self, securityToken, positionsList):
    """
    Parameters:
     - securityToken
     - positionsList
    """
    self.send_getDocumentUriFromId(securityToken, positionsList)
    return self.recv_getDocumentUriFromId()

  def send_getDocumentUriFromId(self, securityToken, positionsList):
    self._oprot.writeMessageBegin('getDocumentUriFromId', TMessageType.CALL, self._seqid)
    args = getDocumentUriFromId_args()
    args.securityToken = securityToken
    args.positionsList = positionsList
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDocumentUriFromId(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDocumentUriFromId_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDocumentUriFromId failed: unknown result");

  def getDocumentConvertedUrisFromIds(self, securityToken, ids):
    """
    Parameters:
     - securityToken
     - ids
    """
    self.send_getDocumentConvertedUrisFromIds(securityToken, ids)
    return self.recv_getDocumentConvertedUrisFromIds()

  def send_getDocumentConvertedUrisFromIds(self, securityToken, ids):
    self._oprot.writeMessageBegin('getDocumentConvertedUrisFromIds', TMessageType.CALL, self._seqid)
    args = getDocumentConvertedUrisFromIds_args()
    args.securityToken = securityToken
    args.ids = ids
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDocumentConvertedUrisFromIds(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDocumentConvertedUrisFromIds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDocumentConvertedUrisFromIds failed: unknown result");

  def getDocumentConvertedUrisFromUris(self, securityToken, uris):
    """
    Parameters:
     - securityToken
     - uris
    """
    self.send_getDocumentConvertedUrisFromUris(securityToken, uris)
    return self.recv_getDocumentConvertedUrisFromUris()

  def send_getDocumentConvertedUrisFromUris(self, securityToken, uris):
    self._oprot.writeMessageBegin('getDocumentConvertedUrisFromUris', TMessageType.CALL, self._seqid)
    args = getDocumentConvertedUrisFromUris_args()
    args.securityToken = securityToken
    args.uris = uris
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDocumentConvertedUrisFromUris(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDocumentConvertedUrisFromUris_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDocumentConvertedUrisFromUris failed: unknown result");

  def getPurgeInfo(self, securityToken, purgeId):
    """
    Parameters:
     - securityToken
     - purgeId
    """
    self.send_getPurgeInfo(securityToken, purgeId)
    return self.recv_getPurgeInfo()

  def send_getPurgeInfo(self, securityToken, purgeId):
    self._oprot.writeMessageBegin('getPurgeInfo', TMessageType.CALL, self._seqid)
    args = getPurgeInfo_args()
    args.securityToken = securityToken
    args.purgeId = purgeId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getPurgeInfo(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getPurgeInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    if result.purgeNotFound is not None:
      raise result.purgeNotFound
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getPurgeInfo failed: unknown result");

  def getAllPurgeIds(self, securityToken):
    """
    Parameters:
     - securityToken
    """
    self.send_getAllPurgeIds(securityToken)
    return self.recv_getAllPurgeIds()

  def send_getAllPurgeIds(self, securityToken):
    self._oprot.writeMessageBegin('getAllPurgeIds', TMessageType.CALL, self._seqid)
    args = getAllPurgeIds_args()
    args.securityToken = securityToken
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllPurgeIds(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllPurgeIds_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllPurgeIds failed: unknown result");

  def updatePurge(self, securityToken, purgeId, completelyPurged, note, resolved):
    """
    Parameters:
     - securityToken
     - purgeId
     - completelyPurged
     - note
     - resolved
    """
    self.send_updatePurge(securityToken, purgeId, completelyPurged, note, resolved)
    self.recv_updatePurge()

  def send_updatePurge(self, securityToken, purgeId, completelyPurged, note, resolved):
    self._oprot.writeMessageBegin('updatePurge', TMessageType.CALL, self._seqid)
    args = updatePurge_args()
    args.securityToken = securityToken
    args.purgeId = purgeId
    args.completelyPurged = completelyPurged
    args.note = note
    args.resolved = resolved
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updatePurge(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updatePurge_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    if result.purgeNotFound is not None:
      raise result.purgeNotFound
    if result.documentNotInPurge is not None:
      raise result.documentNotInPurge
    return

  def removeDocumentAgeOffRuleInheritance(self, securityToken, documentId, documentUri, parentId, parentUri):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - parentId
     - parentUri
    """
    self.send_removeDocumentAgeOffRuleInheritance(securityToken, documentId, documentUri, parentId, parentUri)
    self.recv_removeDocumentAgeOffRuleInheritance()

  def send_removeDocumentAgeOffRuleInheritance(self, securityToken, documentId, documentUri, parentId, parentUri):
    self._oprot.writeMessageBegin('removeDocumentAgeOffRuleInheritance', TMessageType.CALL, self._seqid)
    args = removeDocumentAgeOffRuleInheritance_args()
    args.securityToken = securityToken
    args.documentId = documentId
    args.documentUri = documentUri
    args.parentId = parentId
    args.parentUri = parentUri
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeDocumentAgeOffRuleInheritance(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeDocumentAgeOffRuleInheritance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    if result.documentNotFound is not None:
      raise result.documentNotFound
    if result.alreadyAged is not None:
      raise result.alreadyAged
    return

  def removeDocumentExplicitAgeOffRule(self, securityToken, documentId, documentUri, ageOffRuleId):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - ageOffRuleId
    """
    self.send_removeDocumentExplicitAgeOffRule(securityToken, documentId, documentUri, ageOffRuleId)
    self.recv_removeDocumentExplicitAgeOffRule()

  def send_removeDocumentExplicitAgeOffRule(self, securityToken, documentId, documentUri, ageOffRuleId):
    self._oprot.writeMessageBegin('removeDocumentExplicitAgeOffRule', TMessageType.CALL, self._seqid)
    args = removeDocumentExplicitAgeOffRule_args()
    args.securityToken = securityToken
    args.documentId = documentId
    args.documentUri = documentUri
    args.ageOffRuleId = ageOffRuleId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeDocumentExplicitAgeOffRule(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeDocumentExplicitAgeOffRule_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    if result.documentNotFound is not None:
      raise result.documentNotFound
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    if result.alreadyAged is not None:
      raise result.alreadyAged
    return

  def addDocumentExplicitAgeOffRule(self, securityToken, documentId, documentUri, ageOffMapping):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - ageOffMapping
    """
    self.send_addDocumentExplicitAgeOffRule(securityToken, documentId, documentUri, ageOffMapping)
    self.recv_addDocumentExplicitAgeOffRule()

  def send_addDocumentExplicitAgeOffRule(self, securityToken, documentId, documentUri, ageOffMapping):
    self._oprot.writeMessageBegin('addDocumentExplicitAgeOffRule', TMessageType.CALL, self._seqid)
    args = addDocumentExplicitAgeOffRule_args()
    args.securityToken = securityToken
    args.documentId = documentId
    args.documentUri = documentUri
    args.ageOffMapping = ageOffMapping
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addDocumentExplicitAgeOffRule(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addDocumentExplicitAgeOffRule_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    if result.documentNotFound is not None:
      raise result.documentNotFound
    if result.ruleNotFound is not None:
      raise result.ruleNotFound
    if result.alreadyAged is not None:
      raise result.alreadyAged
    if result.edgeExists is not None:
      raise result.edgeExists
    return

  def addDocumentInheritanceInfo(self, securityToken, documentId, documentUri, inheritanceInfo):
    """
    Parameters:
     - securityToken
     - documentId
     - documentUri
     - inheritanceInfo
    """
    self.send_addDocumentInheritanceInfo(securityToken, documentId, documentUri, inheritanceInfo)
    self.recv_addDocumentInheritanceInfo()

  def send_addDocumentInheritanceInfo(self, securityToken, documentId, documentUri, inheritanceInfo):
    self._oprot.writeMessageBegin('addDocumentInheritanceInfo', TMessageType.CALL, self._seqid)
    args = addDocumentInheritanceInfo_args()
    args.securityToken = securityToken
    args.documentId = documentId
    args.documentUri = documentUri
    args.inheritanceInfo = inheritanceInfo
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addDocumentInheritanceInfo(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addDocumentInheritanceInfo_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    if result.documentNotFound is not None:
      raise result.documentNotFound
    if result.circularInheritance is not None:
      raise result.circularInheritance
    if result.alreadyAged is not None:
      raise result.alreadyAged
    if result.inheritanceExists is not None:
      raise result.inheritanceExists
    return

  def recordObjectAccess(self, securityToken, documentUri, accessType):
    """
    Parameters:
     - securityToken
     - documentUri
     - accessType
    """
    self.send_recordObjectAccess(securityToken, documentUri, accessType)
    self.recv_recordObjectAccess()

  def send_recordObjectAccess(self, securityToken, documentUri, accessType):
    self._oprot.writeMessageBegin('recordObjectAccess', TMessageType.CALL, self._seqid)
    args = recordObjectAccess_args()
    args.securityToken = securityToken
    args.documentUri = documentUri
    args.accessType = accessType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_recordObjectAccess(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = recordObjectAccess_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.security is not None:
      raise result.security
    return

  def fetchUsersDocuments(self, securityToken, userPrincipal, startDateTime, stopDateTime, numToFetch, continuationPoint):
    """
    Parameters:
     - securityToken
     - userPrincipal
     - startDateTime
     - stopDateTime
     - numToFetch
     - continuationPoint
    """
    self.send_fetchUsersDocuments(securityToken, userPrincipal, startDateTime, stopDateTime, numToFetch, continuationPoint)
    return self.recv_fetchUsersDocuments()

  def send_fetchUsersDocuments(self, securityToken, userPrincipal, startDateTime, stopDateTime, numToFetch, continuationPoint):
    self._oprot.writeMessageBegin('fetchUsersDocuments', TMessageType.CALL, self._seqid)
    args = fetchUsersDocuments_args()
    args.securityToken = securityToken
    args.userPrincipal = userPrincipal
    args.startDateTime = startDateTime
    args.stopDateTime = stopDateTime
    args.numToFetch = numToFetch
    args.continuationPoint = continuationPoint
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fetchUsersDocuments(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = fetchUsersDocuments_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fetchUsersDocuments failed: unknown result");

  def fetchDocumentUsers(self, securityToken, documentUri, startDateTime, stopDateTime, numToFetch, continuationPoint):
    """
    Parameters:
     - securityToken
     - documentUri
     - startDateTime
     - stopDateTime
     - numToFetch
     - continuationPoint
    """
    self.send_fetchDocumentUsers(securityToken, documentUri, startDateTime, stopDateTime, numToFetch, continuationPoint)
    return self.recv_fetchDocumentUsers()

  def send_fetchDocumentUsers(self, securityToken, documentUri, startDateTime, stopDateTime, numToFetch, continuationPoint):
    self._oprot.writeMessageBegin('fetchDocumentUsers', TMessageType.CALL, self._seqid)
    args = fetchDocumentUsers_args()
    args.securityToken = securityToken
    args.documentUri = documentUri
    args.startDateTime = startDateTime
    args.stopDateTime = stopDateTime
    args.numToFetch = numToFetch
    args.continuationPoint = continuationPoint
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fetchDocumentUsers(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = fetchDocumentUsers_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.security is not None:
      raise result.security
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fetchDocumentUsers failed: unknown result");


class Processor(ezbakeBaseService.EzBakeBaseService.Processor, Iface, TProcessor):
  def __init__(self, handler):
    ezbakeBaseService.EzBakeBaseService.Processor.__init__(self, handler)
    self._processMap["addAgeOffRule"] = Processor.process_addAgeOffRule
    self._processMap["getAgeOffRuleById"] = Processor.process_getAgeOffRuleById
    self._processMap["getAgeOffRule"] = Processor.process_getAgeOffRule
    self._processMap["updateAgeOffRule"] = Processor.process_updateAgeOffRule
    self._processMap["getAllAgeOffRules"] = Processor.process_getAllAgeOffRules
    self._processMap["countAgeOffRules"] = Processor.process_countAgeOffRules
    self._processMap["addDocument"] = Processor.process_addDocument
    self._processMap["addDocuments"] = Processor.process_addDocuments
    self._processMap["getAddDocumentsMaxSize"] = Processor.process_getAddDocumentsMaxSize
    self._processMap["startAgeOffEvent"] = Processor.process_startAgeOffEvent
    self._processMap["markDocumentAsAged"] = Processor.process_markDocumentAsAged
    self._processMap["getDocumentInfo"] = Processor.process_getDocumentInfo
    self._processMap["getDocumentAncestors"] = Processor.process_getDocumentAncestors
    self._processMap["getDocumentDescendants"] = Processor.process_getDocumentDescendants
    self._processMap["markDocumentForPurge"] = Processor.process_markDocumentForPurge
    self._processMap["getDocumentUriFromId"] = Processor.process_getDocumentUriFromId
    self._processMap["getDocumentConvertedUrisFromIds"] = Processor.process_getDocumentConvertedUrisFromIds
    self._processMap["getDocumentConvertedUrisFromUris"] = Processor.process_getDocumentConvertedUrisFromUris
    self._processMap["getPurgeInfo"] = Processor.process_getPurgeInfo
    self._processMap["getAllPurgeIds"] = Processor.process_getAllPurgeIds
    self._processMap["updatePurge"] = Processor.process_updatePurge
    self._processMap["removeDocumentAgeOffRuleInheritance"] = Processor.process_removeDocumentAgeOffRuleInheritance
    self._processMap["removeDocumentExplicitAgeOffRule"] = Processor.process_removeDocumentExplicitAgeOffRule
    self._processMap["addDocumentExplicitAgeOffRule"] = Processor.process_addDocumentExplicitAgeOffRule
    self._processMap["addDocumentInheritanceInfo"] = Processor.process_addDocumentInheritanceInfo
    self._processMap["recordObjectAccess"] = Processor.process_recordObjectAccess
    self._processMap["fetchUsersDocuments"] = Processor.process_fetchUsersDocuments
    self._processMap["fetchDocumentUsers"] = Processor.process_fetchDocumentUsers

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_addAgeOffRule(self, seqid, iprot, oprot):
    args = addAgeOffRule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addAgeOffRule_result()
    try:
      result.success = self._handler.addAgeOffRule(args.securityToken, args.name, args.retentionDurationSeconds, args.maximumExecutionPeriod)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceAgeOffRuleNameExistsException, nameExists:
      result.nameExists = nameExists
    except ProvenanceIllegalAgeOffDurationSecondsException, illegalAgeOffDurationSeconds:
      result.illegalAgeOffDurationSeconds = illegalAgeOffDurationSeconds
    except ProvenanceIllegalAgeOffRuleNameException, illegalAgeOffName:
      result.illegalAgeOffName = illegalAgeOffName
    except ProvenanceIllegalMaximumExecutionPeriodException, illegalMaxPeriod:
      result.illegalMaxPeriod = illegalMaxPeriod
    oprot.writeMessageBegin("addAgeOffRule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAgeOffRuleById(self, seqid, iprot, oprot):
    args = getAgeOffRuleById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAgeOffRuleById_result()
    try:
      result.success = self._handler.getAgeOffRuleById(args.securityToken, args.ruleId)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    oprot.writeMessageBegin("getAgeOffRuleById", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAgeOffRule(self, seqid, iprot, oprot):
    args = getAgeOffRule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAgeOffRule_result()
    try:
      result.success = self._handler.getAgeOffRule(args.securityToken, args.name)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    oprot.writeMessageBegin("getAgeOffRule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateAgeOffRule(self, seqid, iprot, oprot):
    args = updateAgeOffRule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateAgeOffRule_result()
    try:
      self._handler.updateAgeOffRule(args.securityToken, args.name, args.retentionDurationSeconds)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    except ProvenanceIllegalAgeOffDurationSecondsException, illegalAgeOffDurationSeconds:
      result.illegalAgeOffDurationSeconds = illegalAgeOffDurationSeconds
    except ProvenanceIllegalAgeOffRuleNameException, illegalAgeOffName:
      result.illegalAgeOffName = illegalAgeOffName
    oprot.writeMessageBegin("updateAgeOffRule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllAgeOffRules(self, seqid, iprot, oprot):
    args = getAllAgeOffRules_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllAgeOffRules_result()
    try:
      result.success = self._handler.getAllAgeOffRules(args.securityToken, args.limit, args.page)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getAllAgeOffRules", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_countAgeOffRules(self, seqid, iprot, oprot):
    args = countAgeOffRules_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = countAgeOffRules_result()
    try:
      result.success = self._handler.countAgeOffRules(args.securityToken)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("countAgeOffRules", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addDocument(self, seqid, iprot, oprot):
    args = addDocument_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addDocument_result()
    try:
      result.success = self._handler.addDocument(args.token, args.uri, args.parents, args.ageOffRules)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceDocumentExistsException, documentExists:
      result.documentExists = documentExists
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    except ProvenanceParentDocumentNotFoundException, parentNotFound:
      result.parentNotFound = parentNotFound
    except ProvenanceCircularInheritanceNotAllowedException, circularInheritanceNotAllowed:
      result.circularInheritanceNotAllowed = circularInheritanceNotAllowed
    oprot.writeMessageBegin("addDocument", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addDocuments(self, seqid, iprot, oprot):
    args = addDocuments_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addDocuments_result()
    try:
      result.success = self._handler.addDocuments(args.securityToken, args.documents, args.ageOffRules)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    except ProvenanceExceedsMaxBatchSizeException, exceedsMaxSize:
      result.exceedsMaxSize = exceedsMaxSize
    oprot.writeMessageBegin("addDocuments", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAddDocumentsMaxSize(self, seqid, iprot, oprot):
    args = getAddDocumentsMaxSize_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAddDocumentsMaxSize_result()
    try:
      result.success = self._handler.getAddDocumentsMaxSize(args.securityToken)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getAddDocumentsMaxSize", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startAgeOffEvent(self, seqid, iprot, oprot):
    args = startAgeOffEvent_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startAgeOffEvent_result()
    try:
      result.success = self._handler.startAgeOffEvent(args.securityToken, args.ruleId, args.effectiveTime)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    oprot.writeMessageBegin("startAgeOffEvent", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markDocumentAsAged(self, seqid, iprot, oprot):
    args = markDocumentAsAged_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markDocumentAsAged_result()
    try:
      self._handler.markDocumentAsAged(args.securityToken, args.agedDocumentIds)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceDocumentNotFoundException, documentNotFound:
      result.documentNotFound = documentNotFound
    oprot.writeMessageBegin("markDocumentAsAged", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDocumentInfo(self, seqid, iprot, oprot):
    args = getDocumentInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDocumentInfo_result()
    try:
      result.success = self._handler.getDocumentInfo(args.securityToken, args.id, args.uri)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceDocumentNotFoundException, docNotFound:
      result.docNotFound = docNotFound
    oprot.writeMessageBegin("getDocumentInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDocumentAncestors(self, seqid, iprot, oprot):
    args = getDocumentAncestors_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDocumentAncestors_result()
    try:
      result.success = self._handler.getDocumentAncestors(args.securityToken, args.uris)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getDocumentAncestors", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDocumentDescendants(self, seqid, iprot, oprot):
    args = getDocumentDescendants_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDocumentDescendants_result()
    try:
      result.success = self._handler.getDocumentDescendants(args.securityToken, args.uris)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getDocumentDescendants", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_markDocumentForPurge(self, seqid, iprot, oprot):
    args = markDocumentForPurge_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = markDocumentForPurge_result()
    try:
      result.success = self._handler.markDocumentForPurge(args.securityToken, args.uris, args.name, args.description)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("markDocumentForPurge", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDocumentUriFromId(self, seqid, iprot, oprot):
    args = getDocumentUriFromId_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDocumentUriFromId_result()
    try:
      result.success = self._handler.getDocumentUriFromId(args.securityToken, args.positionsList)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getDocumentUriFromId", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDocumentConvertedUrisFromIds(self, seqid, iprot, oprot):
    args = getDocumentConvertedUrisFromIds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDocumentConvertedUrisFromIds_result()
    try:
      result.success = self._handler.getDocumentConvertedUrisFromIds(args.securityToken, args.ids)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getDocumentConvertedUrisFromIds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDocumentConvertedUrisFromUris(self, seqid, iprot, oprot):
    args = getDocumentConvertedUrisFromUris_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDocumentConvertedUrisFromUris_result()
    try:
      result.success = self._handler.getDocumentConvertedUrisFromUris(args.securityToken, args.uris)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getDocumentConvertedUrisFromUris", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getPurgeInfo(self, seqid, iprot, oprot):
    args = getPurgeInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getPurgeInfo_result()
    try:
      result.success = self._handler.getPurgeInfo(args.securityToken, args.purgeId)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenancePurgeIdNotFoundException, purgeNotFound:
      result.purgeNotFound = purgeNotFound
    oprot.writeMessageBegin("getPurgeInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllPurgeIds(self, seqid, iprot, oprot):
    args = getAllPurgeIds_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllPurgeIds_result()
    try:
      result.success = self._handler.getAllPurgeIds(args.securityToken)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("getAllPurgeIds", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updatePurge(self, seqid, iprot, oprot):
    args = updatePurge_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updatePurge_result()
    try:
      self._handler.updatePurge(args.securityToken, args.purgeId, args.completelyPurged, args.note, args.resolved)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenancePurgeIdNotFoundException, purgeNotFound:
      result.purgeNotFound = purgeNotFound
    except ProvenanceDocumentNotInPurgeException, documentNotInPurge:
      result.documentNotInPurge = documentNotInPurge
    oprot.writeMessageBegin("updatePurge", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeDocumentAgeOffRuleInheritance(self, seqid, iprot, oprot):
    args = removeDocumentAgeOffRuleInheritance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeDocumentAgeOffRuleInheritance_result()
    try:
      self._handler.removeDocumentAgeOffRuleInheritance(args.securityToken, args.documentId, args.documentUri, args.parentId, args.parentUri)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceDocumentNotFoundException, documentNotFound:
      result.documentNotFound = documentNotFound
    except ProvenanceAlreadyAgedException, alreadyAged:
      result.alreadyAged = alreadyAged
    oprot.writeMessageBegin("removeDocumentAgeOffRuleInheritance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeDocumentExplicitAgeOffRule(self, seqid, iprot, oprot):
    args = removeDocumentExplicitAgeOffRule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeDocumentExplicitAgeOffRule_result()
    try:
      self._handler.removeDocumentExplicitAgeOffRule(args.securityToken, args.documentId, args.documentUri, args.ageOffRuleId)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceDocumentNotFoundException, documentNotFound:
      result.documentNotFound = documentNotFound
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    except ProvenanceAlreadyAgedException, alreadyAged:
      result.alreadyAged = alreadyAged
    oprot.writeMessageBegin("removeDocumentExplicitAgeOffRule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addDocumentExplicitAgeOffRule(self, seqid, iprot, oprot):
    args = addDocumentExplicitAgeOffRule_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addDocumentExplicitAgeOffRule_result()
    try:
      self._handler.addDocumentExplicitAgeOffRule(args.securityToken, args.documentId, args.documentUri, args.ageOffMapping)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceDocumentNotFoundException, documentNotFound:
      result.documentNotFound = documentNotFound
    except ProvenanceAgeOffRuleNotFoundException, ruleNotFound:
      result.ruleNotFound = ruleNotFound
    except ProvenanceAlreadyAgedException, alreadyAged:
      result.alreadyAged = alreadyAged
    except ProvenanceAgeOffExistsException, edgeExists:
      result.edgeExists = edgeExists
    oprot.writeMessageBegin("addDocumentExplicitAgeOffRule", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addDocumentInheritanceInfo(self, seqid, iprot, oprot):
    args = addDocumentInheritanceInfo_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addDocumentInheritanceInfo_result()
    try:
      self._handler.addDocumentInheritanceInfo(args.securityToken, args.documentId, args.documentUri, args.inheritanceInfo)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    except ProvenanceDocumentNotFoundException, documentNotFound:
      result.documentNotFound = documentNotFound
    except ProvenanceCircularInheritanceNotAllowedException, circularInheritance:
      result.circularInheritance = circularInheritance
    except ProvenanceAlreadyAgedException, alreadyAged:
      result.alreadyAged = alreadyAged
    except ProvenanceAgeOffInheritanceExistsException, inheritanceExists:
      result.inheritanceExists = inheritanceExists
    oprot.writeMessageBegin("addDocumentInheritanceInfo", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_recordObjectAccess(self, seqid, iprot, oprot):
    args = recordObjectAccess_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = recordObjectAccess_result()
    try:
      self._handler.recordObjectAccess(args.securityToken, args.documentUri, args.accessType)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("recordObjectAccess", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fetchUsersDocuments(self, seqid, iprot, oprot):
    args = fetchUsersDocuments_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fetchUsersDocuments_result()
    try:
      result.success = self._handler.fetchUsersDocuments(args.securityToken, args.userPrincipal, args.startDateTime, args.stopDateTime, args.numToFetch, args.continuationPoint)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("fetchUsersDocuments", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fetchDocumentUsers(self, seqid, iprot, oprot):
    args = fetchDocumentUsers_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fetchDocumentUsers_result()
    try:
      result.success = self._handler.fetchDocumentUsers(args.securityToken, args.documentUri, args.startDateTime, args.stopDateTime, args.numToFetch, args.continuationPoint)
    except ezbakeBaseTypes.ttypes.EzSecurityTokenException, security:
      result.security = security
    oprot.writeMessageBegin("fetchDocumentUsers", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class addAgeOffRule_args(object):
  """
  Attributes:
   - securityToken
   - name
   - retentionDurationSeconds
   - maximumExecutionPeriod
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.I64, 'retentionDurationSeconds', None, None, ), # 3
    (4, TType.I32, 'maximumExecutionPeriod', None, None, ), # 4
  )

  def __init__(self, securityToken=None, name=None, retentionDurationSeconds=None, maximumExecutionPeriod=None,):
    self.securityToken = securityToken
    self.name = name
    self.retentionDurationSeconds = retentionDurationSeconds
    self.maximumExecutionPeriod = maximumExecutionPeriod

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.retentionDurationSeconds = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maximumExecutionPeriod = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addAgeOffRule_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.retentionDurationSeconds is not None:
      oprot.writeFieldBegin('retentionDurationSeconds', TType.I64, 3)
      oprot.writeI64(self.retentionDurationSeconds)
      oprot.writeFieldEnd()
    if self.maximumExecutionPeriod is not None:
      oprot.writeFieldBegin('maximumExecutionPeriod', TType.I32, 4)
      oprot.writeI32(self.maximumExecutionPeriod)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.retentionDurationSeconds is None:
      raise TProtocol.TProtocolException(message='Required field retentionDurationSeconds is unset!')
    if self.maximumExecutionPeriod is None:
      raise TProtocol.TProtocolException(message='Required field maximumExecutionPeriod is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addAgeOffRule_result(object):
  """
  Attributes:
   - success
   - security
   - nameExists
   - illegalAgeOffDurationSeconds
   - illegalAgeOffName
   - illegalMaxPeriod
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nameExists', (ProvenanceAgeOffRuleNameExistsException, ProvenanceAgeOffRuleNameExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'illegalAgeOffDurationSeconds', (ProvenanceIllegalAgeOffDurationSecondsException, ProvenanceIllegalAgeOffDurationSecondsException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'illegalAgeOffName', (ProvenanceIllegalAgeOffRuleNameException, ProvenanceIllegalAgeOffRuleNameException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'illegalMaxPeriod', (ProvenanceIllegalMaximumExecutionPeriodException, ProvenanceIllegalMaximumExecutionPeriodException.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, security=None, nameExists=None, illegalAgeOffDurationSeconds=None, illegalAgeOffName=None, illegalMaxPeriod=None,):
    self.success = success
    self.security = security
    self.nameExists = nameExists
    self.illegalAgeOffDurationSeconds = illegalAgeOffDurationSeconds
    self.illegalAgeOffName = illegalAgeOffName
    self.illegalMaxPeriod = illegalMaxPeriod

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nameExists = ProvenanceAgeOffRuleNameExistsException()
          self.nameExists.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.illegalAgeOffDurationSeconds = ProvenanceIllegalAgeOffDurationSecondsException()
          self.illegalAgeOffDurationSeconds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.illegalAgeOffName = ProvenanceIllegalAgeOffRuleNameException()
          self.illegalAgeOffName.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.illegalMaxPeriod = ProvenanceIllegalMaximumExecutionPeriodException()
          self.illegalMaxPeriod.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addAgeOffRule_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.nameExists is not None:
      oprot.writeFieldBegin('nameExists', TType.STRUCT, 2)
      self.nameExists.write(oprot)
      oprot.writeFieldEnd()
    if self.illegalAgeOffDurationSeconds is not None:
      oprot.writeFieldBegin('illegalAgeOffDurationSeconds', TType.STRUCT, 3)
      self.illegalAgeOffDurationSeconds.write(oprot)
      oprot.writeFieldEnd()
    if self.illegalAgeOffName is not None:
      oprot.writeFieldBegin('illegalAgeOffName', TType.STRUCT, 4)
      self.illegalAgeOffName.write(oprot)
      oprot.writeFieldEnd()
    if self.illegalMaxPeriod is not None:
      oprot.writeFieldBegin('illegalMaxPeriod', TType.STRUCT, 5)
      self.illegalMaxPeriod.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAgeOffRuleById_args(object):
  """
  Attributes:
   - securityToken
   - ruleId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'ruleId', None, None, ), # 2
  )

  def __init__(self, securityToken=None, ruleId=None,):
    self.securityToken = securityToken
    self.ruleId = ruleId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ruleId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAgeOffRuleById_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleId is not None:
      oprot.writeFieldBegin('ruleId', TType.I64, 2)
      oprot.writeI64(self.ruleId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.ruleId is None:
      raise TProtocol.TProtocolException(message='Required field ruleId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAgeOffRuleById_result(object):
  """
  Attributes:
   - success
   - security
   - ruleNotFound
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AgeOffRule, AgeOffRule.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, security=None, ruleNotFound=None,):
    self.success = success
    self.security = security
    self.ruleNotFound = ruleNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AgeOffRule()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAgeOffRuleById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 2)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAgeOffRule_args(object):
  """
  Attributes:
   - securityToken
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, securityToken=None, name=None,):
    self.securityToken = securityToken
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAgeOffRule_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAgeOffRule_result(object):
  """
  Attributes:
   - success
   - security
   - ruleNotFound
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AgeOffRule, AgeOffRule.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    None, # 2
    (3, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, security=None, ruleNotFound=None,):
    self.success = success
    self.security = security
    self.ruleNotFound = ruleNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AgeOffRule()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAgeOffRule_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 3)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateAgeOffRule_args(object):
  """
  Attributes:
   - securityToken
   - name
   - retentionDurationSeconds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.I64, 'retentionDurationSeconds', None, None, ), # 3
  )

  def __init__(self, securityToken=None, name=None, retentionDurationSeconds=None,):
    self.securityToken = securityToken
    self.name = name
    self.retentionDurationSeconds = retentionDurationSeconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.retentionDurationSeconds = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateAgeOffRule_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.retentionDurationSeconds is not None:
      oprot.writeFieldBegin('retentionDurationSeconds', TType.I64, 3)
      oprot.writeI64(self.retentionDurationSeconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.retentionDurationSeconds is None:
      raise TProtocol.TProtocolException(message='Required field retentionDurationSeconds is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateAgeOffRule_result(object):
  """
  Attributes:
   - security
   - ruleNotFound
   - illegalAgeOffDurationSeconds
   - illegalAgeOffName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'illegalAgeOffDurationSeconds', (ProvenanceIllegalAgeOffDurationSecondsException, ProvenanceIllegalAgeOffDurationSecondsException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'illegalAgeOffName', (ProvenanceIllegalAgeOffRuleNameException, ProvenanceIllegalAgeOffRuleNameException.thrift_spec), None, ), # 4
  )

  def __init__(self, security=None, ruleNotFound=None, illegalAgeOffDurationSeconds=None, illegalAgeOffName=None,):
    self.security = security
    self.ruleNotFound = ruleNotFound
    self.illegalAgeOffDurationSeconds = illegalAgeOffDurationSeconds
    self.illegalAgeOffName = illegalAgeOffName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.illegalAgeOffDurationSeconds = ProvenanceIllegalAgeOffDurationSecondsException()
          self.illegalAgeOffDurationSeconds.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.illegalAgeOffName = ProvenanceIllegalAgeOffRuleNameException()
          self.illegalAgeOffName.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateAgeOffRule_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 2)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.illegalAgeOffDurationSeconds is not None:
      oprot.writeFieldBegin('illegalAgeOffDurationSeconds', TType.STRUCT, 3)
      self.illegalAgeOffDurationSeconds.write(oprot)
      oprot.writeFieldEnd()
    if self.illegalAgeOffName is not None:
      oprot.writeFieldBegin('illegalAgeOffName', TType.STRUCT, 4)
      self.illegalAgeOffName.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllAgeOffRules_args(object):
  """
  Attributes:
   - securityToken
   - limit
   - page
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I32, 'limit', None, None, ), # 2
    (3, TType.I32, 'page', None, None, ), # 3
  )

  def __init__(self, securityToken=None, limit=None, page=None,):
    self.securityToken = securityToken
    self.limit = limit
    self.page = page

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.limit = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.page = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllAgeOffRules_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 2)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.page is not None:
      oprot.writeFieldBegin('page', TType.I32, 3)
      oprot.writeI32(self.page)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllAgeOffRules_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(AgeOffRule, AgeOffRule.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype177, _size174) = iprot.readListBegin()
          for _i178 in xrange(_size174):
            _elem179 = AgeOffRule()
            _elem179.read(iprot)
            self.success.append(_elem179)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllAgeOffRules_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter180 in self.success:
        iter180.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countAgeOffRules_args(object):
  """
  Attributes:
   - securityToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
  )

  def __init__(self, securityToken=None,):
    self.securityToken = securityToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countAgeOffRules_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class countAgeOffRules_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('countAgeOffRules_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocument_args(object):
  """
  Attributes:
   - token
   - uri
   - parents
   - ageOffRules
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'token', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'uri', None, None, ), # 2
    (3, TType.LIST, 'parents', (TType.STRUCT,(InheritanceInfo, InheritanceInfo.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'ageOffRules', (TType.STRUCT,(AgeOffMapping, AgeOffMapping.thrift_spec)), None, ), # 4
  )

  def __init__(self, token=None, uri=None, parents=None, ageOffRules=None,):
    self.token = token
    self.uri = uri
    self.parents = parents
    self.ageOffRules = ageOffRules

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.token = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.token.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parents = []
          (_etype184, _size181) = iprot.readListBegin()
          for _i185 in xrange(_size181):
            _elem186 = InheritanceInfo()
            _elem186.read(iprot)
            self.parents.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ageOffRules = []
          (_etype190, _size187) = iprot.readListBegin()
          for _i191 in xrange(_size187):
            _elem192 = AgeOffMapping()
            _elem192.read(iprot)
            self.ageOffRules.append(_elem192)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocument_args')
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRUCT, 1)
      self.token.write(oprot)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 2)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.parents is not None:
      oprot.writeFieldBegin('parents', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.parents))
      for iter193 in self.parents:
        iter193.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ageOffRules is not None:
      oprot.writeFieldBegin('ageOffRules', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.ageOffRules))
      for iter194 in self.ageOffRules:
        iter194.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.token is None:
      raise TProtocol.TProtocolException(message='Required field token is unset!')
    if self.uri is None:
      raise TProtocol.TProtocolException(message='Required field uri is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocument_result(object):
  """
  Attributes:
   - success
   - security
   - documentExists
   - ruleNotFound
   - parentNotFound
   - circularInheritanceNotAllowed
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'documentExists', (ProvenanceDocumentExistsException, ProvenanceDocumentExistsException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'parentNotFound', (ProvenanceParentDocumentNotFoundException, ProvenanceParentDocumentNotFoundException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'circularInheritanceNotAllowed', (ProvenanceCircularInheritanceNotAllowedException, ProvenanceCircularInheritanceNotAllowedException.thrift_spec), None, ), # 5
  )

  def __init__(self, success=None, security=None, documentExists=None, ruleNotFound=None, parentNotFound=None, circularInheritanceNotAllowed=None,):
    self.success = success
    self.security = security
    self.documentExists = documentExists
    self.ruleNotFound = ruleNotFound
    self.parentNotFound = parentNotFound
    self.circularInheritanceNotAllowed = circularInheritanceNotAllowed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.documentExists = ProvenanceDocumentExistsException()
          self.documentExists.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.parentNotFound = ProvenanceParentDocumentNotFoundException()
          self.parentNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.circularInheritanceNotAllowed = ProvenanceCircularInheritanceNotAllowedException()
          self.circularInheritanceNotAllowed.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocument_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.documentExists is not None:
      oprot.writeFieldBegin('documentExists', TType.STRUCT, 2)
      self.documentExists.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 3)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.parentNotFound is not None:
      oprot.writeFieldBegin('parentNotFound', TType.STRUCT, 4)
      self.parentNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.circularInheritanceNotAllowed is not None:
      oprot.writeFieldBegin('circularInheritanceNotAllowed', TType.STRUCT, 5)
      self.circularInheritanceNotAllowed.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocuments_args(object):
  """
  Attributes:
   - securityToken
   - documents
   - ageOffRules
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.SET, 'documents', (TType.STRUCT,(AddDocumentEntry, AddDocumentEntry.thrift_spec)), None, ), # 2
    (3, TType.SET, 'ageOffRules', (TType.STRUCT,(AgeOffMapping, AgeOffMapping.thrift_spec)), None, ), # 3
  )

  def __init__(self, securityToken=None, documents=None, ageOffRules=None,):
    self.securityToken = securityToken
    self.documents = documents
    self.ageOffRules = ageOffRules

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.documents = set()
          (_etype198, _size195) = iprot.readSetBegin()
          for _i199 in xrange(_size195):
            _elem200 = AddDocumentEntry()
            _elem200.read(iprot)
            self.documents.add(_elem200)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.ageOffRules = set()
          (_etype204, _size201) = iprot.readSetBegin()
          for _i205 in xrange(_size201):
            _elem206 = AgeOffMapping()
            _elem206.read(iprot)
            self.ageOffRules.add(_elem206)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocuments_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.documents is not None:
      oprot.writeFieldBegin('documents', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.documents))
      for iter207 in self.documents:
        iter207.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.ageOffRules is not None:
      oprot.writeFieldBegin('ageOffRules', TType.SET, 3)
      oprot.writeSetBegin(TType.STRUCT, len(self.ageOffRules))
      for iter208 in self.ageOffRules:
        iter208.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.documents is None:
      raise TProtocol.TProtocolException(message='Required field documents is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocuments_result(object):
  """
  Attributes:
   - success
   - security
   - ruleNotFound
   - exceedsMaxSize
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRUCT,(AddDocumentResult, AddDocumentResult.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'exceedsMaxSize', (ProvenanceExceedsMaxBatchSizeException, ProvenanceExceedsMaxBatchSizeException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, security=None, ruleNotFound=None, exceedsMaxSize=None,):
    self.success = success
    self.security = security
    self.ruleNotFound = ruleNotFound
    self.exceedsMaxSize = exceedsMaxSize

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype210, _vtype211, _size209 ) = iprot.readMapBegin()
          for _i213 in xrange(_size209):
            _key214 = iprot.readString();
            _val215 = AddDocumentResult()
            _val215.read(iprot)
            self.success[_key214] = _val215
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.exceedsMaxSize = ProvenanceExceedsMaxBatchSizeException()
          self.exceedsMaxSize.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocuments_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
      for kiter216,viter217 in self.success.items():
        oprot.writeString(kiter216)
        viter217.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 2)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.exceedsMaxSize is not None:
      oprot.writeFieldBegin('exceedsMaxSize', TType.STRUCT, 3)
      self.exceedsMaxSize.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAddDocumentsMaxSize_args(object):
  """
  Attributes:
   - securityToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
  )

  def __init__(self, securityToken=None,):
    self.securityToken = securityToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAddDocumentsMaxSize_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAddDocumentsMaxSize_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAddDocumentsMaxSize_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startAgeOffEvent_args(object):
  """
  Attributes:
   - securityToken
   - ruleId
   - effectiveTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'ruleId', None, None, ), # 2
    (3, TType.STRUCT, 'effectiveTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 3
  )

  def __init__(self, securityToken=None, ruleId=None, effectiveTime=None,):
    self.securityToken = securityToken
    self.ruleId = ruleId
    self.effectiveTime = effectiveTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ruleId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.effectiveTime = ezbakeBaseTypes.ttypes.DateTime()
          self.effectiveTime.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startAgeOffEvent_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleId is not None:
      oprot.writeFieldBegin('ruleId', TType.I64, 2)
      oprot.writeI64(self.ruleId)
      oprot.writeFieldEnd()
    if self.effectiveTime is not None:
      oprot.writeFieldBegin('effectiveTime', TType.STRUCT, 3)
      self.effectiveTime.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.ruleId is None:
      raise TProtocol.TProtocolException(message='Required field ruleId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startAgeOffEvent_result(object):
  """
  Attributes:
   - success
   - security
   - ruleNotFound
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (AgeOffInitiationResult, AgeOffInitiationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, security=None, ruleNotFound=None,):
    self.success = success
    self.security = security
    self.ruleNotFound = ruleNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AgeOffInitiationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startAgeOffEvent_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 2)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markDocumentAsAged_args(object):
  """
  Attributes:
   - securityToken
   - agedDocumentIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.SET, 'agedDocumentIds', (TType.I64,None), None, ), # 2
  )

  def __init__(self, securityToken=None, agedDocumentIds=None,):
    self.securityToken = securityToken
    self.agedDocumentIds = agedDocumentIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.agedDocumentIds = set()
          (_etype221, _size218) = iprot.readSetBegin()
          for _i222 in xrange(_size218):
            _elem223 = iprot.readI64();
            self.agedDocumentIds.add(_elem223)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markDocumentAsAged_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.agedDocumentIds is not None:
      oprot.writeFieldBegin('agedDocumentIds', TType.SET, 2)
      oprot.writeSetBegin(TType.I64, len(self.agedDocumentIds))
      for iter224 in self.agedDocumentIds:
        oprot.writeI64(iter224)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.agedDocumentIds is None:
      raise TProtocol.TProtocolException(message='Required field agedDocumentIds is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markDocumentAsAged_result(object):
  """
  Attributes:
   - security
   - documentNotFound
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'documentNotFound', (ProvenanceDocumentNotFoundException, ProvenanceDocumentNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, security=None, documentNotFound=None,):
    self.security = security
    self.documentNotFound = documentNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.documentNotFound = ProvenanceDocumentNotFoundException()
          self.documentNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markDocumentAsAged_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.documentNotFound is not None:
      oprot.writeFieldBegin('documentNotFound', TType.STRUCT, 2)
      self.documentNotFound.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentInfo_args(object):
  """
  Attributes:
   - securityToken
   - id
   - uri
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'id', None, None, ), # 2
    (3, TType.STRING, 'uri', None, None, ), # 3
  )

  def __init__(self, securityToken=None, id=None, uri=None,):
    self.securityToken = securityToken
    self.id = id
    self.uri = uri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentInfo_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 3)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentInfo_result(object):
  """
  Attributes:
   - success
   - security
   - docNotFound
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DocumentInfo, DocumentInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'docNotFound', (ProvenanceDocumentNotFoundException, ProvenanceDocumentNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, security=None, docNotFound=None,):
    self.success = success
    self.security = security
    self.docNotFound = docNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DocumentInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.docNotFound = ProvenanceDocumentNotFoundException()
          self.docNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.docNotFound is not None:
      oprot.writeFieldBegin('docNotFound', TType.STRUCT, 2)
      self.docNotFound.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentAncestors_args(object):
  """
  Attributes:
   - securityToken
   - uris
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.LIST, 'uris', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, securityToken=None, uris=None,):
    self.securityToken = securityToken
    self.uris = uris

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.uris = []
          (_etype228, _size225) = iprot.readListBegin()
          for _i229 in xrange(_size225):
            _elem230 = iprot.readString();
            self.uris.append(_elem230)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentAncestors_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.uris is not None:
      oprot.writeFieldBegin('uris', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.uris))
      for iter231 in self.uris:
        oprot.writeString(iter231)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.uris is None:
      raise TProtocol.TProtocolException(message='Required field uris is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentAncestors_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DerivedResult, DerivedResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DerivedResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentAncestors_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentDescendants_args(object):
  """
  Attributes:
   - securityToken
   - uris
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.LIST, 'uris', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, securityToken=None, uris=None,):
    self.securityToken = securityToken
    self.uris = uris

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.uris = []
          (_etype235, _size232) = iprot.readListBegin()
          for _i236 in xrange(_size232):
            _elem237 = iprot.readString();
            self.uris.append(_elem237)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentDescendants_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.uris is not None:
      oprot.writeFieldBegin('uris', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.uris))
      for iter238 in self.uris:
        oprot.writeString(iter238)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.uris is None:
      raise TProtocol.TProtocolException(message='Required field uris is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentDescendants_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (DerivedResult, DerivedResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = DerivedResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentDescendants_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markDocumentForPurge_args(object):
  """
  Attributes:
   - securityToken
   - uris
   - name
   - description
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.LIST, 'uris', (TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'name', None, None, ), # 3
    (4, TType.STRING, 'description', None, None, ), # 4
  )

  def __init__(self, securityToken=None, uris=None, name=None, description=None,):
    self.securityToken = securityToken
    self.uris = uris
    self.name = name
    self.description = description

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.uris = []
          (_etype242, _size239) = iprot.readListBegin()
          for _i243 in xrange(_size239):
            _elem244 = iprot.readString();
            self.uris.append(_elem244)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markDocumentForPurge_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.uris is not None:
      oprot.writeFieldBegin('uris', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.uris))
      for iter245 in self.uris:
        oprot.writeString(iter245)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 4)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.uris is None:
      raise TProtocol.TProtocolException(message='Required field uris is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class markDocumentForPurge_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PurgeInitiationResult, PurgeInitiationResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PurgeInitiationResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('markDocumentForPurge_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentUriFromId_args(object):
  """
  Attributes:
   - securityToken
   - positionsList
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.LIST, 'positionsList', (TType.I64,None), None, ), # 2
  )

  def __init__(self, securityToken=None, positionsList=None,):
    self.securityToken = securityToken
    self.positionsList = positionsList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.positionsList = []
          (_etype249, _size246) = iprot.readListBegin()
          for _i250 in xrange(_size246):
            _elem251 = iprot.readI64();
            self.positionsList.append(_elem251)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentUriFromId_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.positionsList is not None:
      oprot.writeFieldBegin('positionsList', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.positionsList))
      for iter252 in self.positionsList:
        oprot.writeI64(iter252)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.positionsList is None:
      raise TProtocol.TProtocolException(message='Required field positionsList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentUriFromId_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PositionsToUris, PositionsToUris.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PositionsToUris()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentUriFromId_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentConvertedUrisFromIds_args(object):
  """
  Attributes:
   - securityToken
   - ids
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.SET, 'ids', (TType.I64,None), None, ), # 2
  )

  def __init__(self, securityToken=None, ids=None,):
    self.securityToken = securityToken
    self.ids = ids

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.ids = set()
          (_etype256, _size253) = iprot.readSetBegin()
          for _i257 in xrange(_size253):
            _elem258 = iprot.readI64();
            self.ids.add(_elem258)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentConvertedUrisFromIds_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.ids is not None:
      oprot.writeFieldBegin('ids', TType.SET, 2)
      oprot.writeSetBegin(TType.I64, len(self.ids))
      for iter259 in self.ids:
        oprot.writeI64(iter259)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.ids is None:
      raise TProtocol.TProtocolException(message='Required field ids is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentConvertedUrisFromIds_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ConversionResult, ConversionResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ConversionResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentConvertedUrisFromIds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentConvertedUrisFromUris_args(object):
  """
  Attributes:
   - securityToken
   - uris
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.SET, 'uris', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, securityToken=None, uris=None,):
    self.securityToken = securityToken
    self.uris = uris

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.uris = set()
          (_etype263, _size260) = iprot.readSetBegin()
          for _i264 in xrange(_size260):
            _elem265 = iprot.readString();
            self.uris.add(_elem265)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentConvertedUrisFromUris_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.uris is not None:
      oprot.writeFieldBegin('uris', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.uris))
      for iter266 in self.uris:
        oprot.writeString(iter266)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.uris is None:
      raise TProtocol.TProtocolException(message='Required field uris is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDocumentConvertedUrisFromUris_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ConversionResult, ConversionResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ConversionResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDocumentConvertedUrisFromUris_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPurgeInfo_args(object):
  """
  Attributes:
   - securityToken
   - purgeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'purgeId', None, None, ), # 2
  )

  def __init__(self, securityToken=None, purgeId=None,):
    self.securityToken = securityToken
    self.purgeId = purgeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.purgeId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPurgeInfo_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.purgeId is not None:
      oprot.writeFieldBegin('purgeId', TType.I64, 2)
      oprot.writeI64(self.purgeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.purgeId is None:
      raise TProtocol.TProtocolException(message='Required field purgeId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getPurgeInfo_result(object):
  """
  Attributes:
   - success
   - security
   - purgeNotFound
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PurgeInfo, PurgeInfo.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'purgeNotFound', (ProvenancePurgeIdNotFoundException, ProvenancePurgeIdNotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, security=None, purgeNotFound=None,):
    self.success = success
    self.security = security
    self.purgeNotFound = purgeNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PurgeInfo()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.purgeNotFound = ProvenancePurgeIdNotFoundException()
          self.purgeNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getPurgeInfo_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.purgeNotFound is not None:
      oprot.writeFieldBegin('purgeNotFound', TType.STRUCT, 2)
      self.purgeNotFound.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllPurgeIds_args(object):
  """
  Attributes:
   - securityToken
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
  )

  def __init__(self, securityToken=None,):
    self.securityToken = securityToken

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllPurgeIds_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllPurgeIds_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I64,None), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype270, _size267) = iprot.readListBegin()
          for _i271 in xrange(_size267):
            _elem272 = iprot.readI64();
            self.success.append(_elem272)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllPurgeIds_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I64, len(self.success))
      for iter273 in self.success:
        oprot.writeI64(iter273)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updatePurge_args(object):
  """
  Attributes:
   - securityToken
   - purgeId
   - completelyPurged
   - note
   - resolved
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'purgeId', None, None, ), # 2
    (3, TType.SET, 'completelyPurged', (TType.I64,None), None, ), # 3
    (4, TType.STRING, 'note', None, None, ), # 4
    (5, TType.BOOL, 'resolved', None, None, ), # 5
  )

  def __init__(self, securityToken=None, purgeId=None, completelyPurged=None, note=None, resolved=None,):
    self.securityToken = securityToken
    self.purgeId = purgeId
    self.completelyPurged = completelyPurged
    self.note = note
    self.resolved = resolved

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.purgeId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.completelyPurged = set()
          (_etype277, _size274) = iprot.readSetBegin()
          for _i278 in xrange(_size274):
            _elem279 = iprot.readI64();
            self.completelyPurged.add(_elem279)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.note = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.resolved = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updatePurge_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.purgeId is not None:
      oprot.writeFieldBegin('purgeId', TType.I64, 2)
      oprot.writeI64(self.purgeId)
      oprot.writeFieldEnd()
    if self.completelyPurged is not None:
      oprot.writeFieldBegin('completelyPurged', TType.SET, 3)
      oprot.writeSetBegin(TType.I64, len(self.completelyPurged))
      for iter280 in self.completelyPurged:
        oprot.writeI64(iter280)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.note is not None:
      oprot.writeFieldBegin('note', TType.STRING, 4)
      oprot.writeString(self.note)
      oprot.writeFieldEnd()
    if self.resolved is not None:
      oprot.writeFieldBegin('resolved', TType.BOOL, 5)
      oprot.writeBool(self.resolved)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.purgeId is None:
      raise TProtocol.TProtocolException(message='Required field purgeId is unset!')
    if self.completelyPurged is None:
      raise TProtocol.TProtocolException(message='Required field completelyPurged is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updatePurge_result(object):
  """
  Attributes:
   - security
   - purgeNotFound
   - documentNotInPurge
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'purgeNotFound', (ProvenancePurgeIdNotFoundException, ProvenancePurgeIdNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'documentNotInPurge', (ProvenanceDocumentNotInPurgeException, ProvenanceDocumentNotInPurgeException.thrift_spec), None, ), # 3
  )

  def __init__(self, security=None, purgeNotFound=None, documentNotInPurge=None,):
    self.security = security
    self.purgeNotFound = purgeNotFound
    self.documentNotInPurge = documentNotInPurge

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.purgeNotFound = ProvenancePurgeIdNotFoundException()
          self.purgeNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.documentNotInPurge = ProvenanceDocumentNotInPurgeException()
          self.documentNotInPurge.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updatePurge_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.purgeNotFound is not None:
      oprot.writeFieldBegin('purgeNotFound', TType.STRUCT, 2)
      self.purgeNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.documentNotInPurge is not None:
      oprot.writeFieldBegin('documentNotInPurge', TType.STRUCT, 3)
      self.documentNotInPurge.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeDocumentAgeOffRuleInheritance_args(object):
  """
  Attributes:
   - securityToken
   - documentId
   - documentUri
   - parentId
   - parentUri
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'documentId', None, None, ), # 2
    (3, TType.STRING, 'documentUri', None, None, ), # 3
    (4, TType.I64, 'parentId', None, None, ), # 4
    (5, TType.STRING, 'parentUri', None, None, ), # 5
  )

  def __init__(self, securityToken=None, documentId=None, documentUri=None, parentId=None, parentUri=None,):
    self.securityToken = securityToken
    self.documentId = documentId
    self.documentUri = documentUri
    self.parentId = parentId
    self.parentUri = parentUri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.documentId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.documentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.parentId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.parentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeDocumentAgeOffRuleInheritance_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.documentId is not None:
      oprot.writeFieldBegin('documentId', TType.I64, 2)
      oprot.writeI64(self.documentId)
      oprot.writeFieldEnd()
    if self.documentUri is not None:
      oprot.writeFieldBegin('documentUri', TType.STRING, 3)
      oprot.writeString(self.documentUri)
      oprot.writeFieldEnd()
    if self.parentId is not None:
      oprot.writeFieldBegin('parentId', TType.I64, 4)
      oprot.writeI64(self.parentId)
      oprot.writeFieldEnd()
    if self.parentUri is not None:
      oprot.writeFieldBegin('parentUri', TType.STRING, 5)
      oprot.writeString(self.parentUri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeDocumentAgeOffRuleInheritance_result(object):
  """
  Attributes:
   - security
   - documentNotFound
   - alreadyAged
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'documentNotFound', (ProvenanceDocumentNotFoundException, ProvenanceDocumentNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'alreadyAged', (ProvenanceAlreadyAgedException, ProvenanceAlreadyAgedException.thrift_spec), None, ), # 3
  )

  def __init__(self, security=None, documentNotFound=None, alreadyAged=None,):
    self.security = security
    self.documentNotFound = documentNotFound
    self.alreadyAged = alreadyAged

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.documentNotFound = ProvenanceDocumentNotFoundException()
          self.documentNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.alreadyAged = ProvenanceAlreadyAgedException()
          self.alreadyAged.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeDocumentAgeOffRuleInheritance_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.documentNotFound is not None:
      oprot.writeFieldBegin('documentNotFound', TType.STRUCT, 2)
      self.documentNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.alreadyAged is not None:
      oprot.writeFieldBegin('alreadyAged', TType.STRUCT, 3)
      self.alreadyAged.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeDocumentExplicitAgeOffRule_args(object):
  """
  Attributes:
   - securityToken
   - documentId
   - documentUri
   - ageOffRuleId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'documentId', None, None, ), # 2
    (3, TType.STRING, 'documentUri', None, None, ), # 3
    (4, TType.I64, 'ageOffRuleId', None, None, ), # 4
  )

  def __init__(self, securityToken=None, documentId=None, documentUri=None, ageOffRuleId=None,):
    self.securityToken = securityToken
    self.documentId = documentId
    self.documentUri = documentUri
    self.ageOffRuleId = ageOffRuleId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.documentId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.documentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.ageOffRuleId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeDocumentExplicitAgeOffRule_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.documentId is not None:
      oprot.writeFieldBegin('documentId', TType.I64, 2)
      oprot.writeI64(self.documentId)
      oprot.writeFieldEnd()
    if self.documentUri is not None:
      oprot.writeFieldBegin('documentUri', TType.STRING, 3)
      oprot.writeString(self.documentUri)
      oprot.writeFieldEnd()
    if self.ageOffRuleId is not None:
      oprot.writeFieldBegin('ageOffRuleId', TType.I64, 4)
      oprot.writeI64(self.ageOffRuleId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.ageOffRuleId is None:
      raise TProtocol.TProtocolException(message='Required field ageOffRuleId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeDocumentExplicitAgeOffRule_result(object):
  """
  Attributes:
   - security
   - documentNotFound
   - ruleNotFound
   - alreadyAged
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'documentNotFound', (ProvenanceDocumentNotFoundException, ProvenanceDocumentNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'alreadyAged', (ProvenanceAlreadyAgedException, ProvenanceAlreadyAgedException.thrift_spec), None, ), # 4
  )

  def __init__(self, security=None, documentNotFound=None, ruleNotFound=None, alreadyAged=None,):
    self.security = security
    self.documentNotFound = documentNotFound
    self.ruleNotFound = ruleNotFound
    self.alreadyAged = alreadyAged

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.documentNotFound = ProvenanceDocumentNotFoundException()
          self.documentNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.alreadyAged = ProvenanceAlreadyAgedException()
          self.alreadyAged.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeDocumentExplicitAgeOffRule_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.documentNotFound is not None:
      oprot.writeFieldBegin('documentNotFound', TType.STRUCT, 2)
      self.documentNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 3)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.alreadyAged is not None:
      oprot.writeFieldBegin('alreadyAged', TType.STRUCT, 4)
      self.alreadyAged.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocumentExplicitAgeOffRule_args(object):
  """
  Attributes:
   - securityToken
   - documentId
   - documentUri
   - ageOffMapping
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'documentId', None, None, ), # 2
    (3, TType.STRING, 'documentUri', None, None, ), # 3
    (4, TType.STRUCT, 'ageOffMapping', (AgeOffMapping, AgeOffMapping.thrift_spec), None, ), # 4
  )

  def __init__(self, securityToken=None, documentId=None, documentUri=None, ageOffMapping=None,):
    self.securityToken = securityToken
    self.documentId = documentId
    self.documentUri = documentUri
    self.ageOffMapping = ageOffMapping

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.documentId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.documentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ageOffMapping = AgeOffMapping()
          self.ageOffMapping.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocumentExplicitAgeOffRule_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.documentId is not None:
      oprot.writeFieldBegin('documentId', TType.I64, 2)
      oprot.writeI64(self.documentId)
      oprot.writeFieldEnd()
    if self.documentUri is not None:
      oprot.writeFieldBegin('documentUri', TType.STRING, 3)
      oprot.writeString(self.documentUri)
      oprot.writeFieldEnd()
    if self.ageOffMapping is not None:
      oprot.writeFieldBegin('ageOffMapping', TType.STRUCT, 4)
      self.ageOffMapping.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.ageOffMapping is None:
      raise TProtocol.TProtocolException(message='Required field ageOffMapping is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocumentExplicitAgeOffRule_result(object):
  """
  Attributes:
   - security
   - documentNotFound
   - ruleNotFound
   - alreadyAged
   - edgeExists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'documentNotFound', (ProvenanceDocumentNotFoundException, ProvenanceDocumentNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ruleNotFound', (ProvenanceAgeOffRuleNotFoundException, ProvenanceAgeOffRuleNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'alreadyAged', (ProvenanceAlreadyAgedException, ProvenanceAlreadyAgedException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'edgeExists', (ProvenanceAgeOffExistsException, ProvenanceAgeOffExistsException.thrift_spec), None, ), # 5
  )

  def __init__(self, security=None, documentNotFound=None, ruleNotFound=None, alreadyAged=None, edgeExists=None,):
    self.security = security
    self.documentNotFound = documentNotFound
    self.ruleNotFound = ruleNotFound
    self.alreadyAged = alreadyAged
    self.edgeExists = edgeExists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.documentNotFound = ProvenanceDocumentNotFoundException()
          self.documentNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ruleNotFound = ProvenanceAgeOffRuleNotFoundException()
          self.ruleNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.alreadyAged = ProvenanceAlreadyAgedException()
          self.alreadyAged.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.edgeExists = ProvenanceAgeOffExistsException()
          self.edgeExists.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocumentExplicitAgeOffRule_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.documentNotFound is not None:
      oprot.writeFieldBegin('documentNotFound', TType.STRUCT, 2)
      self.documentNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.ruleNotFound is not None:
      oprot.writeFieldBegin('ruleNotFound', TType.STRUCT, 3)
      self.ruleNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.alreadyAged is not None:
      oprot.writeFieldBegin('alreadyAged', TType.STRUCT, 4)
      self.alreadyAged.write(oprot)
      oprot.writeFieldEnd()
    if self.edgeExists is not None:
      oprot.writeFieldBegin('edgeExists', TType.STRUCT, 5)
      self.edgeExists.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocumentInheritanceInfo_args(object):
  """
  Attributes:
   - securityToken
   - documentId
   - documentUri
   - inheritanceInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.I64, 'documentId', None, None, ), # 2
    (3, TType.STRING, 'documentUri', None, None, ), # 3
    (4, TType.STRUCT, 'inheritanceInfo', (InheritanceInfo, InheritanceInfo.thrift_spec), None, ), # 4
  )

  def __init__(self, securityToken=None, documentId=None, documentUri=None, inheritanceInfo=None,):
    self.securityToken = securityToken
    self.documentId = documentId
    self.documentUri = documentUri
    self.inheritanceInfo = inheritanceInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.documentId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.documentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.inheritanceInfo = InheritanceInfo()
          self.inheritanceInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocumentInheritanceInfo_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.documentId is not None:
      oprot.writeFieldBegin('documentId', TType.I64, 2)
      oprot.writeI64(self.documentId)
      oprot.writeFieldEnd()
    if self.documentUri is not None:
      oprot.writeFieldBegin('documentUri', TType.STRING, 3)
      oprot.writeString(self.documentUri)
      oprot.writeFieldEnd()
    if self.inheritanceInfo is not None:
      oprot.writeFieldBegin('inheritanceInfo', TType.STRUCT, 4)
      self.inheritanceInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.inheritanceInfo is None:
      raise TProtocol.TProtocolException(message='Required field inheritanceInfo is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addDocumentInheritanceInfo_result(object):
  """
  Attributes:
   - security
   - documentNotFound
   - circularInheritance
   - alreadyAged
   - inheritanceExists
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'documentNotFound', (ProvenanceDocumentNotFoundException, ProvenanceDocumentNotFoundException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'circularInheritance', (ProvenanceCircularInheritanceNotAllowedException, ProvenanceCircularInheritanceNotAllowedException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'alreadyAged', (ProvenanceAlreadyAgedException, ProvenanceAlreadyAgedException.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'inheritanceExists', (ProvenanceAgeOffInheritanceExistsException, ProvenanceAgeOffInheritanceExistsException.thrift_spec), None, ), # 5
  )

  def __init__(self, security=None, documentNotFound=None, circularInheritance=None, alreadyAged=None, inheritanceExists=None,):
    self.security = security
    self.documentNotFound = documentNotFound
    self.circularInheritance = circularInheritance
    self.alreadyAged = alreadyAged
    self.inheritanceExists = inheritanceExists

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.documentNotFound = ProvenanceDocumentNotFoundException()
          self.documentNotFound.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.circularInheritance = ProvenanceCircularInheritanceNotAllowedException()
          self.circularInheritance.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.alreadyAged = ProvenanceAlreadyAgedException()
          self.alreadyAged.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.inheritanceExists = ProvenanceAgeOffInheritanceExistsException()
          self.inheritanceExists.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addDocumentInheritanceInfo_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    if self.documentNotFound is not None:
      oprot.writeFieldBegin('documentNotFound', TType.STRUCT, 2)
      self.documentNotFound.write(oprot)
      oprot.writeFieldEnd()
    if self.circularInheritance is not None:
      oprot.writeFieldBegin('circularInheritance', TType.STRUCT, 3)
      self.circularInheritance.write(oprot)
      oprot.writeFieldEnd()
    if self.alreadyAged is not None:
      oprot.writeFieldBegin('alreadyAged', TType.STRUCT, 4)
      self.alreadyAged.write(oprot)
      oprot.writeFieldEnd()
    if self.inheritanceExists is not None:
      oprot.writeFieldBegin('inheritanceExists', TType.STRUCT, 5)
      self.inheritanceExists.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class recordObjectAccess_args(object):
  """
  Attributes:
   - securityToken
   - documentUri
   - accessType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'documentUri', None, None, ), # 2
    (3, TType.I32, 'accessType', None, None, ), # 3
  )

  def __init__(self, securityToken=None, documentUri=None, accessType=None,):
    self.securityToken = securityToken
    self.documentUri = documentUri
    self.accessType = accessType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.documentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.accessType = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('recordObjectAccess_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.documentUri is not None:
      oprot.writeFieldBegin('documentUri', TType.STRING, 2)
      oprot.writeString(self.documentUri)
      oprot.writeFieldEnd()
    if self.accessType is not None:
      oprot.writeFieldBegin('accessType', TType.I32, 3)
      oprot.writeI32(self.accessType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.securityToken is None:
      raise TProtocol.TProtocolException(message='Required field securityToken is unset!')
    if self.documentUri is None:
      raise TProtocol.TProtocolException(message='Required field documentUri is unset!')
    if self.accessType is None:
      raise TProtocol.TProtocolException(message='Required field accessType is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class recordObjectAccess_result(object):
  """
  Attributes:
   - security
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, security=None,):
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('recordObjectAccess_result')
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchUsersDocuments_args(object):
  """
  Attributes:
   - securityToken
   - userPrincipal
   - startDateTime
   - stopDateTime
   - numToFetch
   - continuationPoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'userPrincipal', None, None, ), # 2
    (3, TType.STRUCT, 'startDateTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'stopDateTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 4
    (5, TType.I32, 'numToFetch', None, None, ), # 5
    (6, TType.STRUCT, 'continuationPoint', (AccumuloContinuationPoint, AccumuloContinuationPoint.thrift_spec), None, ), # 6
  )

  def __init__(self, securityToken=None, userPrincipal=None, startDateTime=None, stopDateTime=None, numToFetch=None, continuationPoint=None,):
    self.securityToken = securityToken
    self.userPrincipal = userPrincipal
    self.startDateTime = startDateTime
    self.stopDateTime = stopDateTime
    self.numToFetch = numToFetch
    self.continuationPoint = continuationPoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.userPrincipal = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.startDateTime = ezbakeBaseTypes.ttypes.DateTime()
          self.startDateTime.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stopDateTime = ezbakeBaseTypes.ttypes.DateTime()
          self.stopDateTime.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.numToFetch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.continuationPoint = AccumuloContinuationPoint()
          self.continuationPoint.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchUsersDocuments_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.userPrincipal is not None:
      oprot.writeFieldBegin('userPrincipal', TType.STRING, 2)
      oprot.writeString(self.userPrincipal)
      oprot.writeFieldEnd()
    if self.startDateTime is not None:
      oprot.writeFieldBegin('startDateTime', TType.STRUCT, 3)
      self.startDateTime.write(oprot)
      oprot.writeFieldEnd()
    if self.stopDateTime is not None:
      oprot.writeFieldBegin('stopDateTime', TType.STRUCT, 4)
      self.stopDateTime.write(oprot)
      oprot.writeFieldEnd()
    if self.numToFetch is not None:
      oprot.writeFieldBegin('numToFetch', TType.I32, 5)
      oprot.writeI32(self.numToFetch)
      oprot.writeFieldEnd()
    if self.continuationPoint is not None:
      oprot.writeFieldBegin('continuationPoint', TType.STRUCT, 6)
      self.continuationPoint.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchUsersDocuments_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ResultsAndContinuation, ResultsAndContinuation.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ResultsAndContinuation()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchUsersDocuments_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchDocumentUsers_args(object):
  """
  Attributes:
   - securityToken
   - documentUri
   - startDateTime
   - stopDateTime
   - numToFetch
   - continuationPoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'securityToken', (ezbakeBaseTypes.ttypes.EzSecurityToken, ezbakeBaseTypes.ttypes.EzSecurityToken.thrift_spec), None, ), # 1
    (2, TType.STRING, 'documentUri', None, None, ), # 2
    (3, TType.STRUCT, 'startDateTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'stopDateTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 4
    (5, TType.I32, 'numToFetch', None, None, ), # 5
    (6, TType.STRUCT, 'continuationPoint', (AccumuloContinuationPoint, AccumuloContinuationPoint.thrift_spec), None, ), # 6
  )

  def __init__(self, securityToken=None, documentUri=None, startDateTime=None, stopDateTime=None, numToFetch=None, continuationPoint=None,):
    self.securityToken = securityToken
    self.documentUri = documentUri
    self.startDateTime = startDateTime
    self.stopDateTime = stopDateTime
    self.numToFetch = numToFetch
    self.continuationPoint = continuationPoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.securityToken = ezbakeBaseTypes.ttypes.EzSecurityToken()
          self.securityToken.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.documentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.startDateTime = ezbakeBaseTypes.ttypes.DateTime()
          self.startDateTime.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stopDateTime = ezbakeBaseTypes.ttypes.DateTime()
          self.stopDateTime.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.numToFetch = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.continuationPoint = AccumuloContinuationPoint()
          self.continuationPoint.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchDocumentUsers_args')
    if self.securityToken is not None:
      oprot.writeFieldBegin('securityToken', TType.STRUCT, 1)
      self.securityToken.write(oprot)
      oprot.writeFieldEnd()
    if self.documentUri is not None:
      oprot.writeFieldBegin('documentUri', TType.STRING, 2)
      oprot.writeString(self.documentUri)
      oprot.writeFieldEnd()
    if self.startDateTime is not None:
      oprot.writeFieldBegin('startDateTime', TType.STRUCT, 3)
      self.startDateTime.write(oprot)
      oprot.writeFieldEnd()
    if self.stopDateTime is not None:
      oprot.writeFieldBegin('stopDateTime', TType.STRUCT, 4)
      self.stopDateTime.write(oprot)
      oprot.writeFieldEnd()
    if self.numToFetch is not None:
      oprot.writeFieldBegin('numToFetch', TType.I32, 5)
      oprot.writeI32(self.numToFetch)
      oprot.writeFieldEnd()
    if self.continuationPoint is not None:
      oprot.writeFieldBegin('continuationPoint', TType.STRUCT, 6)
      self.continuationPoint.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetchDocumentUsers_result(object):
  """
  Attributes:
   - success
   - security
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ResultsAndContinuation, ResultsAndContinuation.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'security', (ezbakeBaseTypes.ttypes.EzSecurityTokenException, ezbakeBaseTypes.ttypes.EzSecurityTokenException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, security=None,):
    self.success = success
    self.security = security

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ResultsAndContinuation()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.security = ezbakeBaseTypes.ttypes.EzSecurityTokenException()
          self.security.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetchDocumentUsers_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.security is not None:
      oprot.writeFieldBegin('security', TType.STRUCT, 1)
      self.security.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
