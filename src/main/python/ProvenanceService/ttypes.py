#   Copyright (C) 2013-2014 Computer Sciences Corporation
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import ezbakeBaseTypes.ttypes
import ezbakeBaseService.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class AddDocumentStatus(object):
  SUCCESS = 0
  ALREADY_EXISTS = 1
  PARENT_NOT_FOUND = 2
  CIRCULAR_INHERITANCE_NOT_ALLOWED = 3
  UNKNOWN_ERROR = 4

  _VALUES_TO_NAMES = {
    0: "SUCCESS",
    1: "ALREADY_EXISTS",
    2: "PARENT_NOT_FOUND",
    3: "CIRCULAR_INHERITANCE_NOT_ALLOWED",
    4: "UNKNOWN_ERROR",
  }

  _NAMES_TO_VALUES = {
    "SUCCESS": 0,
    "ALREADY_EXISTS": 1,
    "PARENT_NOT_FOUND": 2,
    "CIRCULAR_INHERITANCE_NOT_ALLOWED": 3,
    "UNKNOWN_ERROR": 4,
  }

class ObjectAccessType(object):
  CREATE = 0
  READ = 1
  WRITE = 2
  MANAGE = 3
  DELETE = 4

  _VALUES_TO_NAMES = {
    0: "CREATE",
    1: "READ",
    2: "WRITE",
    3: "MANAGE",
    4: "DELETE",
  }

  _NAMES_TO_VALUES = {
    "CREATE": 0,
    "READ": 1,
    "WRITE": 2,
    "MANAGE": 3,
    "DELETE": 4,
  }


class InheritanceInfo(object):
  """
  Attributes:
   - parentUri
   - inheritParentAgeOff
   - trackParentAgeOff
   - ageOffRelevantDateTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'parentUri', None, None, ), # 1
    (2, TType.BOOL, 'inheritParentAgeOff', None, None, ), # 2
    (3, TType.BOOL, 'trackParentAgeOff', None, None, ), # 3
    (4, TType.STRUCT, 'ageOffRelevantDateTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 4
  )

  def __init__(self, parentUri=None, inheritParentAgeOff=None, trackParentAgeOff=None, ageOffRelevantDateTime=None,):
    self.parentUri = parentUri
    self.inheritParentAgeOff = inheritParentAgeOff
    self.trackParentAgeOff = trackParentAgeOff
    self.ageOffRelevantDateTime = ageOffRelevantDateTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.parentUri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.inheritParentAgeOff = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.trackParentAgeOff = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ageOffRelevantDateTime = ezbakeBaseTypes.ttypes.DateTime()
          self.ageOffRelevantDateTime.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InheritanceInfo')
    if self.parentUri is not None:
      oprot.writeFieldBegin('parentUri', TType.STRING, 1)
      oprot.writeString(self.parentUri)
      oprot.writeFieldEnd()
    if self.inheritParentAgeOff is not None:
      oprot.writeFieldBegin('inheritParentAgeOff', TType.BOOL, 2)
      oprot.writeBool(self.inheritParentAgeOff)
      oprot.writeFieldEnd()
    if self.trackParentAgeOff is not None:
      oprot.writeFieldBegin('trackParentAgeOff', TType.BOOL, 3)
      oprot.writeBool(self.trackParentAgeOff)
      oprot.writeFieldEnd()
    if self.ageOffRelevantDateTime is not None:
      oprot.writeFieldBegin('ageOffRelevantDateTime', TType.STRUCT, 4)
      self.ageOffRelevantDateTime.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.parentUri is None:
      raise TProtocol.TProtocolException(message='Required field parentUri is unset!')
    if self.inheritParentAgeOff is None:
      raise TProtocol.TProtocolException(message='Required field inheritParentAgeOff is unset!')
    if self.trackParentAgeOff is None:
      raise TProtocol.TProtocolException(message='Required field trackParentAgeOff is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AccumuloContinuationPoint(object):
  """
  Attributes:
   - startAtBeginning
   - rowId
   - colFam
   - colQual
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'startAtBeginning', None, None, ), # 1
    (2, TType.STRING, 'rowId', None, None, ), # 2
    (3, TType.STRING, 'colFam', None, None, ), # 3
    (4, TType.STRING, 'colQual', None, None, ), # 4
  )

  def __init__(self, startAtBeginning=None, rowId=None, colFam=None, colQual=None,):
    self.startAtBeginning = startAtBeginning
    self.rowId = rowId
    self.colFam = colFam
    self.colQual = colQual

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.startAtBeginning = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.rowId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.colFam = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.colQual = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AccumuloContinuationPoint')
    if self.startAtBeginning is not None:
      oprot.writeFieldBegin('startAtBeginning', TType.BOOL, 1)
      oprot.writeBool(self.startAtBeginning)
      oprot.writeFieldEnd()
    if self.rowId is not None:
      oprot.writeFieldBegin('rowId', TType.STRING, 2)
      oprot.writeString(self.rowId)
      oprot.writeFieldEnd()
    if self.colFam is not None:
      oprot.writeFieldBegin('colFam', TType.STRING, 3)
      oprot.writeString(self.colFam)
      oprot.writeFieldEnd()
    if self.colQual is not None:
      oprot.writeFieldBegin('colQual', TType.STRING, 4)
      oprot.writeString(self.colQual)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.startAtBeginning is None:
      raise TProtocol.TProtocolException(message='Required field startAtBeginning is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResultsAndContinuation(object):
  """
  Attributes:
   - results
   - continuationPoint
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'results', (TType.STRING,None), None, ), # 1
    (2, TType.STRUCT, 'continuationPoint', (AccumuloContinuationPoint, AccumuloContinuationPoint.thrift_spec), None, ), # 2
  )

  def __init__(self, results=None, continuationPoint=None,):
    self.results = results
    self.continuationPoint = continuationPoint

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.results = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.results.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.continuationPoint = AccumuloContinuationPoint()
          self.continuationPoint.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResultsAndContinuation')
    if self.results is not None:
      oprot.writeFieldBegin('results', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.results))
      for iter6 in self.results:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.continuationPoint is not None:
      oprot.writeFieldBegin('continuationPoint', TType.STRUCT, 2)
      self.continuationPoint.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.results is None:
      raise TProtocol.TProtocolException(message='Required field results is unset!')
    if self.continuationPoint is None:
      raise TProtocol.TProtocolException(message='Required field continuationPoint is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AgeOffMapping(object):
  """
  Attributes:
   - ruleId
   - ageOffRelevantDateTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'ruleId', None, None, ), # 1
    (2, TType.STRUCT, 'ageOffRelevantDateTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 2
  )

  def __init__(self, ruleId=None, ageOffRelevantDateTime=None,):
    self.ruleId = ruleId
    self.ageOffRelevantDateTime = ageOffRelevantDateTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.ruleId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ageOffRelevantDateTime = ezbakeBaseTypes.ttypes.DateTime()
          self.ageOffRelevantDateTime.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AgeOffMapping')
    if self.ruleId is not None:
      oprot.writeFieldBegin('ruleId', TType.I64, 1)
      oprot.writeI64(self.ruleId)
      oprot.writeFieldEnd()
    if self.ageOffRelevantDateTime is not None:
      oprot.writeFieldBegin('ageOffRelevantDateTime', TType.STRUCT, 2)
      self.ageOffRelevantDateTime.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ruleId is None:
      raise TProtocol.TProtocolException(message='Required field ruleId is unset!')
    if self.ageOffRelevantDateTime is None:
      raise TProtocol.TProtocolException(message='Required field ageOffRelevantDateTime is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DerivedResult(object):
  """
  Attributes:
   - derivedDocs
   - urisNotFound
   - immediateChildren
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'derivedDocs', (TType.I64,None), None, ), # 1
    (2, TType.LIST, 'urisNotFound', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'immediateChildren', (TType.I64,None), None, ), # 3
  )

  def __init__(self, derivedDocs=None, urisNotFound=None, immediateChildren=None,):
    self.derivedDocs = derivedDocs
    self.urisNotFound = urisNotFound
    self.immediateChildren = immediateChildren

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.derivedDocs = set()
          (_etype10, _size7) = iprot.readSetBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readI64();
            self.derivedDocs.add(_elem12)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.urisNotFound = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = iprot.readString();
            self.urisNotFound.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.immediateChildren = []
          (_etype22, _size19) = iprot.readListBegin()
          for _i23 in xrange(_size19):
            _elem24 = iprot.readI64();
            self.immediateChildren.append(_elem24)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DerivedResult')
    if self.derivedDocs is not None:
      oprot.writeFieldBegin('derivedDocs', TType.SET, 1)
      oprot.writeSetBegin(TType.I64, len(self.derivedDocs))
      for iter25 in self.derivedDocs:
        oprot.writeI64(iter25)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.urisNotFound is not None:
      oprot.writeFieldBegin('urisNotFound', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.urisNotFound))
      for iter26 in self.urisNotFound:
        oprot.writeString(iter26)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.immediateChildren is not None:
      oprot.writeFieldBegin('immediateChildren', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.immediateChildren))
      for iter27 in self.immediateChildren:
        oprot.writeI64(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.derivedDocs is None:
      raise TProtocol.TProtocolException(message='Required field derivedDocs is unset!')
    if self.urisNotFound is None:
      raise TProtocol.TProtocolException(message='Required field urisNotFound is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DocumentAgeOffInfo(object):
  """
  Attributes:
   - ruleId
   - ageOffRelevantDateTime
   - maximumExecutionPeriod
   - timeStamp
   - application
   - user
   - inherited
   - inheritedFromId
   - inheritedFromUri
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'ruleId', None, None, ), # 1
    (2, TType.STRUCT, 'ageOffRelevantDateTime', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 2
    (3, TType.I32, 'maximumExecutionPeriod', None, None, ), # 3
    (4, TType.STRUCT, 'timeStamp', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 4
    (5, TType.STRING, 'application', None, None, ), # 5
    (6, TType.STRING, 'user', None, None, ), # 6
    (7, TType.BOOL, 'inherited', None, None, ), # 7
    (8, TType.I64, 'inheritedFromId', None, None, ), # 8
    (9, TType.STRING, 'inheritedFromUri', None, None, ), # 9
  )

  def __init__(self, ruleId=None, ageOffRelevantDateTime=None, maximumExecutionPeriod=None, timeStamp=None, application=None, user=None, inherited=None, inheritedFromId=None, inheritedFromUri=None,):
    self.ruleId = ruleId
    self.ageOffRelevantDateTime = ageOffRelevantDateTime
    self.maximumExecutionPeriod = maximumExecutionPeriod
    self.timeStamp = timeStamp
    self.application = application
    self.user = user
    self.inherited = inherited
    self.inheritedFromId = inheritedFromId
    self.inheritedFromUri = inheritedFromUri

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.ruleId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ageOffRelevantDateTime = ezbakeBaseTypes.ttypes.DateTime()
          self.ageOffRelevantDateTime.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maximumExecutionPeriod = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.timeStamp = ezbakeBaseTypes.ttypes.DateTime()
          self.timeStamp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.application = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.inherited = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.inheritedFromId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.inheritedFromUri = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DocumentAgeOffInfo')
    if self.ruleId is not None:
      oprot.writeFieldBegin('ruleId', TType.I64, 1)
      oprot.writeI64(self.ruleId)
      oprot.writeFieldEnd()
    if self.ageOffRelevantDateTime is not None:
      oprot.writeFieldBegin('ageOffRelevantDateTime', TType.STRUCT, 2)
      self.ageOffRelevantDateTime.write(oprot)
      oprot.writeFieldEnd()
    if self.maximumExecutionPeriod is not None:
      oprot.writeFieldBegin('maximumExecutionPeriod', TType.I32, 3)
      oprot.writeI32(self.maximumExecutionPeriod)
      oprot.writeFieldEnd()
    if self.timeStamp is not None:
      oprot.writeFieldBegin('timeStamp', TType.STRUCT, 4)
      self.timeStamp.write(oprot)
      oprot.writeFieldEnd()
    if self.application is not None:
      oprot.writeFieldBegin('application', TType.STRING, 5)
      oprot.writeString(self.application)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 6)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.inherited is not None:
      oprot.writeFieldBegin('inherited', TType.BOOL, 7)
      oprot.writeBool(self.inherited)
      oprot.writeFieldEnd()
    if self.inheritedFromId is not None:
      oprot.writeFieldBegin('inheritedFromId', TType.I64, 8)
      oprot.writeI64(self.inheritedFromId)
      oprot.writeFieldEnd()
    if self.inheritedFromUri is not None:
      oprot.writeFieldBegin('inheritedFromUri', TType.STRING, 9)
      oprot.writeString(self.inheritedFromUri)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ruleId is None:
      raise TProtocol.TProtocolException(message='Required field ruleId is unset!')
    if self.ageOffRelevantDateTime is None:
      raise TProtocol.TProtocolException(message='Required field ageOffRelevantDateTime is unset!')
    if self.maximumExecutionPeriod is None:
      raise TProtocol.TProtocolException(message='Required field maximumExecutionPeriod is unset!')
    if self.timeStamp is None:
      raise TProtocol.TProtocolException(message='Required field timeStamp is unset!')
    if self.application is None:
      raise TProtocol.TProtocolException(message='Required field application is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.inherited is None:
      raise TProtocol.TProtocolException(message='Required field inherited is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DocumentInfo(object):
  """
  Attributes:
   - uri
   - documentId
   - application
   - timeStamp
   - user
   - parents
   - children
   - ageOffInfo
   - aged
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uri', None, None, ), # 1
    (2, TType.I64, 'documentId', None, None, ), # 2
    (3, TType.STRING, 'application', None, None, ), # 3
    (4, TType.STRUCT, 'timeStamp', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 4
    (5, TType.STRING, 'user', None, None, ), # 5
    (6, TType.LIST, 'parents', (TType.MAP,(TType.I64,None,TType.STRING,None)), None, ), # 6
    (7, TType.LIST, 'children', (TType.MAP,(TType.I64,None,TType.STRING,None)), None, ), # 7
    (8, TType.LIST, 'ageOffInfo', (TType.STRUCT,(DocumentAgeOffInfo, DocumentAgeOffInfo.thrift_spec)), None, ), # 8
    (9, TType.BOOL, 'aged', None, None, ), # 9
  )

  def __init__(self, uri=None, documentId=None, application=None, timeStamp=None, user=None, parents=None, children=None, ageOffInfo=None, aged=None,):
    self.uri = uri
    self.documentId = documentId
    self.application = application
    self.timeStamp = timeStamp
    self.user = user
    self.parents = parents
    self.children = children
    self.ageOffInfo = ageOffInfo
    self.aged = aged

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.documentId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.application = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.timeStamp = ezbakeBaseTypes.ttypes.DateTime()
          self.timeStamp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.parents = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = {}
            (_ktype35, _vtype36, _size34 ) = iprot.readMapBegin()
            for _i38 in xrange(_size34):
              _key39 = iprot.readI64();
              _val40 = iprot.readString();
              _elem33[_key39] = _val40
            iprot.readMapEnd()
            self.parents.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.children = []
          (_etype44, _size41) = iprot.readListBegin()
          for _i45 in xrange(_size41):
            _elem46 = {}
            (_ktype48, _vtype49, _size47 ) = iprot.readMapBegin()
            for _i51 in xrange(_size47):
              _key52 = iprot.readI64();
              _val53 = iprot.readString();
              _elem46[_key52] = _val53
            iprot.readMapEnd()
            self.children.append(_elem46)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.ageOffInfo = []
          (_etype57, _size54) = iprot.readListBegin()
          for _i58 in xrange(_size54):
            _elem59 = DocumentAgeOffInfo()
            _elem59.read(iprot)
            self.ageOffInfo.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.aged = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DocumentInfo')
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 1)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.documentId is not None:
      oprot.writeFieldBegin('documentId', TType.I64, 2)
      oprot.writeI64(self.documentId)
      oprot.writeFieldEnd()
    if self.application is not None:
      oprot.writeFieldBegin('application', TType.STRING, 3)
      oprot.writeString(self.application)
      oprot.writeFieldEnd()
    if self.timeStamp is not None:
      oprot.writeFieldBegin('timeStamp', TType.STRUCT, 4)
      self.timeStamp.write(oprot)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 5)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.parents is not None:
      oprot.writeFieldBegin('parents', TType.LIST, 6)
      oprot.writeListBegin(TType.MAP, len(self.parents))
      for iter60 in self.parents:
        oprot.writeMapBegin(TType.I64, TType.STRING, len(iter60))
        for kiter61,viter62 in iter60.items():
          oprot.writeI64(kiter61)
          oprot.writeString(viter62)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.children is not None:
      oprot.writeFieldBegin('children', TType.LIST, 7)
      oprot.writeListBegin(TType.MAP, len(self.children))
      for iter63 in self.children:
        oprot.writeMapBegin(TType.I64, TType.STRING, len(iter63))
        for kiter64,viter65 in iter63.items():
          oprot.writeI64(kiter64)
          oprot.writeString(viter65)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ageOffInfo is not None:
      oprot.writeFieldBegin('ageOffInfo', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.ageOffInfo))
      for iter66 in self.ageOffInfo:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aged is not None:
      oprot.writeFieldBegin('aged', TType.BOOL, 9)
      oprot.writeBool(self.aged)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uri is None:
      raise TProtocol.TProtocolException(message='Required field uri is unset!')
    if self.documentId is None:
      raise TProtocol.TProtocolException(message='Required field documentId is unset!')
    if self.application is None:
      raise TProtocol.TProtocolException(message='Required field application is unset!')
    if self.timeStamp is None:
      raise TProtocol.TProtocolException(message='Required field timeStamp is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.parents is None:
      raise TProtocol.TProtocolException(message='Required field parents is unset!')
    if self.children is None:
      raise TProtocol.TProtocolException(message='Required field children is unset!')
    if self.ageOffInfo is None:
      raise TProtocol.TProtocolException(message='Required field ageOffInfo is unset!')
    if self.aged is None:
      raise TProtocol.TProtocolException(message='Required field aged is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConversionResult(object):
  """
  Attributes:
   - convertedUris
   - urisNotFound
   - idsNotFound
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'convertedUris', (TType.I64,None), None, ), # 1
    (2, TType.LIST, 'urisNotFound', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'idsNotFound', (TType.I64,None), None, ), # 3
  )

  def __init__(self, convertedUris=None, urisNotFound=None, idsNotFound=None,):
    self.convertedUris = convertedUris
    self.urisNotFound = urisNotFound
    self.idsNotFound = idsNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.convertedUris = []
          (_etype70, _size67) = iprot.readListBegin()
          for _i71 in xrange(_size67):
            _elem72 = iprot.readI64();
            self.convertedUris.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.urisNotFound = []
          (_etype76, _size73) = iprot.readListBegin()
          for _i77 in xrange(_size73):
            _elem78 = iprot.readString();
            self.urisNotFound.append(_elem78)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.idsNotFound = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = iprot.readI64();
            self.idsNotFound.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConversionResult')
    if self.convertedUris is not None:
      oprot.writeFieldBegin('convertedUris', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.convertedUris))
      for iter85 in self.convertedUris:
        oprot.writeI64(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.urisNotFound is not None:
      oprot.writeFieldBegin('urisNotFound', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.urisNotFound))
      for iter86 in self.urisNotFound:
        oprot.writeString(iter86)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.idsNotFound is not None:
      oprot.writeFieldBegin('idsNotFound', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.idsNotFound))
      for iter87 in self.idsNotFound:
        oprot.writeI64(iter87)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.convertedUris is None:
      raise TProtocol.TProtocolException(message='Required field convertedUris is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AgeOffInitiationResult(object):
  """
  Attributes:
   - ageOffId
   - ageOffDocumentIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'ageOffId', None, None, ), # 1
    (2, TType.SET, 'ageOffDocumentIds', (TType.I64,None), None, ), # 2
  )

  def __init__(self, ageOffId=None, ageOffDocumentIds=None,):
    self.ageOffId = ageOffId
    self.ageOffDocumentIds = ageOffDocumentIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.ageOffId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.ageOffDocumentIds = set()
          (_etype91, _size88) = iprot.readSetBegin()
          for _i92 in xrange(_size88):
            _elem93 = iprot.readI64();
            self.ageOffDocumentIds.add(_elem93)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AgeOffInitiationResult')
    if self.ageOffId is not None:
      oprot.writeFieldBegin('ageOffId', TType.I64, 1)
      oprot.writeI64(self.ageOffId)
      oprot.writeFieldEnd()
    if self.ageOffDocumentIds is not None:
      oprot.writeFieldBegin('ageOffDocumentIds', TType.SET, 2)
      oprot.writeSetBegin(TType.I64, len(self.ageOffDocumentIds))
      for iter94 in self.ageOffDocumentIds:
        oprot.writeI64(iter94)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ageOffId is None:
      raise TProtocol.TProtocolException(message='Required field ageOffId is unset!')
    if self.ageOffDocumentIds is None:
      raise TProtocol.TProtocolException(message='Required field ageOffDocumentIds is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PurgeInitiationResult(object):
  """
  Attributes:
   - toBePurged
   - urisNotFound
   - purgeId
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'toBePurged', (TType.I64,None), None, ), # 1
    (2, TType.LIST, 'urisNotFound', (TType.STRING,None), None, ), # 2
    (3, TType.I64, 'purgeId', None, None, ), # 3
  )

  def __init__(self, toBePurged=None, urisNotFound=None, purgeId=None,):
    self.toBePurged = toBePurged
    self.urisNotFound = urisNotFound
    self.purgeId = purgeId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.toBePurged = set()
          (_etype98, _size95) = iprot.readSetBegin()
          for _i99 in xrange(_size95):
            _elem100 = iprot.readI64();
            self.toBePurged.add(_elem100)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.urisNotFound = []
          (_etype104, _size101) = iprot.readListBegin()
          for _i105 in xrange(_size101):
            _elem106 = iprot.readString();
            self.urisNotFound.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.purgeId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PurgeInitiationResult')
    if self.toBePurged is not None:
      oprot.writeFieldBegin('toBePurged', TType.SET, 1)
      oprot.writeSetBegin(TType.I64, len(self.toBePurged))
      for iter107 in self.toBePurged:
        oprot.writeI64(iter107)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.urisNotFound is not None:
      oprot.writeFieldBegin('urisNotFound', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.urisNotFound))
      for iter108 in self.urisNotFound:
        oprot.writeString(iter108)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.purgeId is not None:
      oprot.writeFieldBegin('purgeId', TType.I64, 3)
      oprot.writeI64(self.purgeId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.toBePurged is None:
      raise TProtocol.TProtocolException(message='Required field toBePurged is unset!')
    if self.urisNotFound is None:
      raise TProtocol.TProtocolException(message='Required field urisNotFound is unset!')
    if self.purgeId is None:
      raise TProtocol.TProtocolException(message='Required field purgeId is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PurgeInfo(object):
  """
  Attributes:
   - id
   - timeStamp
   - documentUris
   - documentUrisNotFound
   - purgeDocumentIds
   - completelyPurgedDocumentIds
   - user
   - name
   - description
   - resolved
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'timeStamp', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 2
    (3, TType.LIST, 'documentUris', (TType.STRING,None), None, ), # 3
    (4, TType.LIST, 'documentUrisNotFound', (TType.STRING,None), None, ), # 4
    (5, TType.SET, 'purgeDocumentIds', (TType.I64,None), None, ), # 5
    (6, TType.SET, 'completelyPurgedDocumentIds', (TType.I64,None), None, ), # 6
    (7, TType.STRING, 'user', None, None, ), # 7
    (8, TType.STRING, 'name', None, None, ), # 8
    (9, TType.STRING, 'description', None, None, ), # 9
    (10, TType.BOOL, 'resolved', None, None, ), # 10
  )

  def __init__(self, id=None, timeStamp=None, documentUris=None, documentUrisNotFound=None, purgeDocumentIds=None, completelyPurgedDocumentIds=None, user=None, name=None, description=None, resolved=None,):
    self.id = id
    self.timeStamp = timeStamp
    self.documentUris = documentUris
    self.documentUrisNotFound = documentUrisNotFound
    self.purgeDocumentIds = purgeDocumentIds
    self.completelyPurgedDocumentIds = completelyPurgedDocumentIds
    self.user = user
    self.name = name
    self.description = description
    self.resolved = resolved

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.timeStamp = ezbakeBaseTypes.ttypes.DateTime()
          self.timeStamp.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.documentUris = []
          (_etype112, _size109) = iprot.readListBegin()
          for _i113 in xrange(_size109):
            _elem114 = iprot.readString();
            self.documentUris.append(_elem114)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.documentUrisNotFound = []
          (_etype118, _size115) = iprot.readListBegin()
          for _i119 in xrange(_size115):
            _elem120 = iprot.readString();
            self.documentUrisNotFound.append(_elem120)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.purgeDocumentIds = set()
          (_etype124, _size121) = iprot.readSetBegin()
          for _i125 in xrange(_size121):
            _elem126 = iprot.readI64();
            self.purgeDocumentIds.add(_elem126)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.completelyPurgedDocumentIds = set()
          (_etype130, _size127) = iprot.readSetBegin()
          for _i131 in xrange(_size127):
            _elem132 = iprot.readI64();
            self.completelyPurgedDocumentIds.add(_elem132)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.resolved = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PurgeInfo')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.timeStamp is not None:
      oprot.writeFieldBegin('timeStamp', TType.STRUCT, 2)
      self.timeStamp.write(oprot)
      oprot.writeFieldEnd()
    if self.documentUris is not None:
      oprot.writeFieldBegin('documentUris', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.documentUris))
      for iter133 in self.documentUris:
        oprot.writeString(iter133)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.documentUrisNotFound is not None:
      oprot.writeFieldBegin('documentUrisNotFound', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.documentUrisNotFound))
      for iter134 in self.documentUrisNotFound:
        oprot.writeString(iter134)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.purgeDocumentIds is not None:
      oprot.writeFieldBegin('purgeDocumentIds', TType.SET, 5)
      oprot.writeSetBegin(TType.I64, len(self.purgeDocumentIds))
      for iter135 in self.purgeDocumentIds:
        oprot.writeI64(iter135)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.completelyPurgedDocumentIds is not None:
      oprot.writeFieldBegin('completelyPurgedDocumentIds', TType.SET, 6)
      oprot.writeSetBegin(TType.I64, len(self.completelyPurgedDocumentIds))
      for iter136 in self.completelyPurgedDocumentIds:
        oprot.writeI64(iter136)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 7)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 8)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 9)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.resolved is not None:
      oprot.writeFieldBegin('resolved', TType.BOOL, 10)
      oprot.writeBool(self.resolved)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.timeStamp is None:
      raise TProtocol.TProtocolException(message='Required field timeStamp is unset!')
    if self.documentUris is None:
      raise TProtocol.TProtocolException(message='Required field documentUris is unset!')
    if self.documentUrisNotFound is None:
      raise TProtocol.TProtocolException(message='Required field documentUrisNotFound is unset!')
    if self.purgeDocumentIds is None:
      raise TProtocol.TProtocolException(message='Required field purgeDocumentIds is unset!')
    if self.completelyPurgedDocumentIds is None:
      raise TProtocol.TProtocolException(message='Required field completelyPurgedDocumentIds is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.resolved is None:
      raise TProtocol.TProtocolException(message='Required field resolved is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PositionsToUris(object):
  """
  Attributes:
   - mapping
   - unfoundPositionList
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'mapping', (TType.I64,None,TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'unfoundPositionList', (TType.I64,None), None, ), # 2
  )

  def __init__(self, mapping=None, unfoundPositionList=None,):
    self.mapping = mapping
    self.unfoundPositionList = unfoundPositionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.mapping = {}
          (_ktype138, _vtype139, _size137 ) = iprot.readMapBegin()
          for _i141 in xrange(_size137):
            _key142 = iprot.readI64();
            _val143 = iprot.readString();
            self.mapping[_key142] = _val143
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.unfoundPositionList = []
          (_etype147, _size144) = iprot.readListBegin()
          for _i148 in xrange(_size144):
            _elem149 = iprot.readI64();
            self.unfoundPositionList.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PositionsToUris')
    if self.mapping is not None:
      oprot.writeFieldBegin('mapping', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.STRING, len(self.mapping))
      for kiter150,viter151 in self.mapping.items():
        oprot.writeI64(kiter150)
        oprot.writeString(viter151)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.unfoundPositionList is not None:
      oprot.writeFieldBegin('unfoundPositionList', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.unfoundPositionList))
      for iter152 in self.unfoundPositionList:
        oprot.writeI64(iter152)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.mapping is None:
      raise TProtocol.TProtocolException(message='Required field mapping is unset!')
    if self.unfoundPositionList is None:
      raise TProtocol.TProtocolException(message='Required field unfoundPositionList is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AgeOffRule(object):
  """
  Attributes:
   - name
   - id
   - retentionDurationSeconds
   - maximumExecutionPeriod
   - application
   - user
   - timeStamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I64, 'id', None, None, ), # 2
    (3, TType.I64, 'retentionDurationSeconds', None, None, ), # 3
    (4, TType.I32, 'maximumExecutionPeriod', None, None, ), # 4
    (5, TType.STRING, 'application', None, None, ), # 5
    (6, TType.STRING, 'user', None, None, ), # 6
    (7, TType.STRUCT, 'timeStamp', (ezbakeBaseTypes.ttypes.DateTime, ezbakeBaseTypes.ttypes.DateTime.thrift_spec), None, ), # 7
  )

  def __init__(self, name=None, id=None, retentionDurationSeconds=None, maximumExecutionPeriod=None, application=None, user=None, timeStamp=None,):
    self.name = name
    self.id = id
    self.retentionDurationSeconds = retentionDurationSeconds
    self.maximumExecutionPeriod = maximumExecutionPeriod
    self.application = application
    self.user = user
    self.timeStamp = timeStamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.retentionDurationSeconds = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.maximumExecutionPeriod = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.application = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.user = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.timeStamp = ezbakeBaseTypes.ttypes.DateTime()
          self.timeStamp.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AgeOffRule')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.retentionDurationSeconds is not None:
      oprot.writeFieldBegin('retentionDurationSeconds', TType.I64, 3)
      oprot.writeI64(self.retentionDurationSeconds)
      oprot.writeFieldEnd()
    if self.maximumExecutionPeriod is not None:
      oprot.writeFieldBegin('maximumExecutionPeriod', TType.I32, 4)
      oprot.writeI32(self.maximumExecutionPeriod)
      oprot.writeFieldEnd()
    if self.application is not None:
      oprot.writeFieldBegin('application', TType.STRING, 5)
      oprot.writeString(self.application)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 6)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.timeStamp is not None:
      oprot.writeFieldBegin('timeStamp', TType.STRUCT, 7)
      self.timeStamp.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.retentionDurationSeconds is None:
      raise TProtocol.TProtocolException(message='Required field retentionDurationSeconds is unset!')
    if self.maximumExecutionPeriod is None:
      raise TProtocol.TProtocolException(message='Required field maximumExecutionPeriod is unset!')
    if self.application is None:
      raise TProtocol.TProtocolException(message='Required field application is unset!')
    if self.user is None:
      raise TProtocol.TProtocolException(message='Required field user is unset!')
    if self.timeStamp is None:
      raise TProtocol.TProtocolException(message='Required field timeStamp is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddDocumentEntry(object):
  """
  Attributes:
   - uri
   - parents
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uri', None, None, ), # 1
    (2, TType.SET, 'parents', (TType.STRUCT,(InheritanceInfo, InheritanceInfo.thrift_spec)), None, ), # 2
  )

  def __init__(self, uri=None, parents=None,):
    self.uri = uri
    self.parents = parents

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.parents = set()
          (_etype156, _size153) = iprot.readSetBegin()
          for _i157 in xrange(_size153):
            _elem158 = InheritanceInfo()
            _elem158.read(iprot)
            self.parents.add(_elem158)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddDocumentEntry')
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 1)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.parents is not None:
      oprot.writeFieldBegin('parents', TType.SET, 2)
      oprot.writeSetBegin(TType.STRUCT, len(self.parents))
      for iter159 in self.parents:
        iter159.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.uri is None:
      raise TProtocol.TProtocolException(message='Required field uri is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AddDocumentResult(object):
  """
  Attributes:
   - status
   - documentId
   - parentsNotFound
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.I64, 'documentId', None, None, ), # 2
    (3, TType.LIST, 'parentsNotFound', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, status=None, documentId=None, parentsNotFound=None,):
    self.status = status
    self.documentId = documentId
    self.parentsNotFound = parentsNotFound

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.documentId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parentsNotFound = []
          (_etype163, _size160) = iprot.readListBegin()
          for _i164 in xrange(_size160):
            _elem165 = iprot.readString();
            self.parentsNotFound.append(_elem165)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AddDocumentResult')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.documentId is not None:
      oprot.writeFieldBegin('documentId', TType.I64, 2)
      oprot.writeI64(self.documentId)
      oprot.writeFieldEnd()
    if self.parentsNotFound is not None:
      oprot.writeFieldBegin('parentsNotFound', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.parentsNotFound))
      for iter166 in self.parentsNotFound:
        oprot.writeString(iter166)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceDocumentNotFoundException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceDocumentNotFoundException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceParentDocumentNotFoundException(TException):
  """
  Attributes:
   - message
   - parentUris
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
    (2, TType.LIST, 'parentUris', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, message=None, parentUris=None,):
    self.message = message
    self.parentUris = parentUris

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parentUris = []
          (_etype170, _size167) = iprot.readListBegin()
          for _i171 in xrange(_size167):
            _elem172 = iprot.readString();
            self.parentUris.append(_elem172)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceParentDocumentNotFoundException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.parentUris is not None:
      oprot.writeFieldBegin('parentUris', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.parentUris))
      for iter173 in self.parentUris:
        oprot.writeString(iter173)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceAgeOffRuleNameExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceAgeOffRuleNameExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceIllegalAgeOffDurationSecondsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceIllegalAgeOffDurationSecondsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceIllegalAgeOffRuleNameException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceIllegalAgeOffRuleNameException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceIllegalMaximumExecutionPeriodException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceIllegalMaximumExecutionPeriodException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceAgeOffRuleNotFoundException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceAgeOffRuleNotFoundException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceDocumentExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceDocumentExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceCircularInheritanceNotAllowedException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceCircularInheritanceNotAllowedException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenancePurgeIdNotFoundException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenancePurgeIdNotFoundException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceAgeOffExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceAgeOffExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceAgeOffInheritanceExistsException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceAgeOffInheritanceExistsException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceDocumentNotInPurgeException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceDocumentNotInPurgeException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceAlreadyAgedException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceAlreadyAgedException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProvenanceExceedsMaxBatchSizeException(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProvenanceExceedsMaxBatchSizeException')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
